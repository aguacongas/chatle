<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\projects\chatle\src\chatle\Controllers\AccountController.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using ChatLe.Hubs;
using ChatLe.Models;
using ChatLe.ViewModels;
using System.Net;
using ChatLe.Repository.Identity;
using Microsoft.AspNetCore.Http;
using System.Security.Claims;
using System.Linq;
using Microsoft.Extensions.Logging;
using System.Collections.Generic;
using Microsoft.AspNetCore.SignalR;
using Microsoft.AspNetCore.Http.Authentication;
using Microsoft.AspNetCore.Authentication;
using System;

namespace ChatLe.Controllers
{
    [Authorize]
    public class AccountController : Controller
    {
        public AccountController(UserManager&lt;ChatLeUser&gt; userManager, 
            SignInManager signInManager,
            IChatManager&lt;string, ChatLeUser, Conversation, Attendee, Message, NotificationConnection&gt; chatManager,
            IHubContext&lt;ChatHub&gt; hubContext,
            ILoggerFactory loggerFactory)
        {
            UserManager = userManager;
            SignInManager = signInManager;
            ChatManager = chatManager;
            Logger = loggerFactory.CreateLogger&lt;AccountController&gt;();
            HubContext = hubContext;
        }

        public UserManager&lt;ChatLeUser&gt; UserManager { get; private set; }

        public SignInManager&lt;ChatLeUser&gt; SignInManager { get; private set; }

        public IChatManager&lt;string, ChatLeUser, Conversation, Attendee, Message, NotificationConnection&gt; ChatManager { get; private set; }

        public ILogger Logger { get; private set; }

        public IHubContext&lt;ChatHub&gt; HubContext { get; private set; }

        // GET: /Account/Index
        [HttpGet]
        [AllowAnonymous]
        public IActionResult Index(string returnUrl = null, string reason = null)
        {
            ViewBag.ReturnUrl = returnUrl;
            DeleteExternalCookie();
            return View(new LoginPageViewModel());
        }

        //
        // POST: /Account/Login
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; Login(LoginViewModel model, string returnUrl = null)
        {
            if (ModelState.IsValid)
            {
                var signInStatus = await SignInManager.PasswordSignInAsync(model.UserName, model.Password, model.RememberMe, lockoutOnFailure: false);

                if (signInStatus.Succeeded)
                    return RedirectToLocal(returnUrl);

                ModelState.AddModelError(&quot;&quot;, &quot;Invalid username or password.&quot;);
                return View(model);
            }

            // If we got this far, something failed, redisplay form
            return View(&quot;Index&quot;, new LoginPageViewModel() { Login = model });
        }

        //
        // POST: /Account/SpaLogin
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; SpaLogin([FromBody] LoginViewModel model)
        {
            if (ModelState.IsValid)
            {
                var signInStatus = await SignInManager.PasswordSignInAsync(model.UserName, model.Password, model.RememberMe, lockoutOnFailure: false);

                if (signInStatus.Succeeded)
                    return new JsonResult(signInStatus.Succeeded);

                ModelState.AddModelError(&quot;InvalidUserOrPAssword&quot;, &quot;Invalid username or password.&quot;);                
            }

            return ReturnSpaError();
        }

        //
        // POST: /Account/Guess
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; Guess(GuessViewModel model, string returnUrl = null)
        {
            if (ModelState.IsValid)
            {
                var user = new ChatLeUser { UserName = model.UserName };

                var result = await UserManager.CreateAsync(user);
                
                if (result.Succeeded)
                {
                    await SignInManager.SignInAsync(user, isPersistent: false);
                    return RedirectToAction(&quot;Index&quot;, &quot;Home&quot;);
                }
                else
                    AddErrors(result);
            }

            // If we got this far, something failed, redisplay form
            return View(&quot;Index&quot;, new LoginPageViewModel() { Guess = model });
        }

        //
        // POST: /Account/SpaGuess
        [HttpPost]
        [AllowAnonymous]
        public async Task&lt;JsonResult&gt; SpaGuess([FromBody] GuessViewModel model)
        {
            if (ModelState.IsValid)
            {
                var user = new ChatLeUser { UserName = model.UserName };
                var result = await UserManager.CreateAsync(user);
                if (result.Succeeded)
                {
                    await SignInManager.SignInAsync(user, isPersistent: false);
                    return new JsonResult(result.Succeeded);
                }
                else
                {
                    AddErrors(result);
                }
            }

            return ReturnSpaError();
        }

        //
        // GET: /Account/Register
        [AllowAnonymous]
        [HttpGet]
        public IActionResult Register()
        {
            return View();
        }

        //
        // POST: /Account/Register
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; Register(RegisterViewModel model)
        {
            if (ModelState.IsValid)
            {
                var user = new ChatLeUser { UserName = model.UserName };
                var result = await UserManager.CreateAsync(user, model.Password);

                if (result.Succeeded)
                {
                    await SignInManager.SignInAsync(user, isPersistent: false);
                    return RedirectToAction(&quot;Index&quot;, &quot;Home&quot;);
                }
                else
                    AddErrors(result);
            }

            // If we got this far, something failed, redisplay form
            return View(model);
        }

        //
        // POST: /Account/LogOff
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; LogOff(string reason = null)
        {
            await SignOut();
			return RedirectToAction(&quot;Index&quot;, routeValues: new { Reason = reason });
        }

        //
        // POST: /Account/SpaLogOff
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task SpaLogOff(string reason = null)
        {
            await SignOut();        
        }

        //
        // GET: /Account/ExternalLoginCallback
        [HttpGet]
        [AllowAnonymous]
        public IEnumerable&lt;ExternalLoginProvider&gt; GetExternalProviders(){
            return SignInManager.GetExternalAuthenticationSchemesAsync().Result.Select(p =&gt; new ExternalLoginProvider
                { 
                    DisplayName = p.DisplayName,
                    AuthenticationScheme = p.Name  
                });
        }

        //
        // POST: /Account/ExternalLogin
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public IActionResult ExternalLogin(string provider, string returnUrl = null)
        {
            // Request a redirect to the external login provider.
            var redirectUrl = Url.Action(&quot;ExternalLoginCallback&quot;, &quot;Account&quot;, new { ReturnUrl = returnUrl });
            var properties = SignInManager.ConfigureExternalAuthenticationProperties(provider, redirectUrl, UserManager.GetUserId(User));
            return Challenge(properties, provider);
        }

        //
        // GET: /Account/ExternalLoginCallback
        [HttpGet]
        [AllowAnonymous]
        public async Task&lt;IActionResult&gt; ExternalLoginCallback(string returnUrl = null, string remoteError = null)
        {
            if (returnUrl != null)
            {
                return await SpaExternalLogin(returnUrl, remoteError);
            }

            if (remoteError != null)
            {
                ModelState.AddModelError(string.Empty, $&quot;Error from external provider: {remoteError}&quot;);
                return View(nameof(Login));
            }

            var info = await SignInManager.GetExternalLoginInfoAsync();
            if (info == null)
            {
                return RedirectToAction(nameof(Index));
            }

            // Sign in the user with this external login provider if the user already has a login.
            var result = await SignInManager.ExternalLoginSignInAsync(info.LoginProvider, info.ProviderKey, isPersistent: false);
            if (result.Succeeded)
            {
                // Update any authentication tokens if login succeeded
                await SignInManager.UpdateExternalAuthenticationTokensAsync(info);

                return RedirectToLocal(returnUrl);
            }

            // If the user does not have an account, then ask the user to create an account.
            ViewData[&quot;LoginProvider&quot;] = info.LoginProvider;
            var name = info.Principal.FindFirstValue(ClaimTypes.Name);

            return View(&quot;ExternalLoginConfirmation&quot;, new ExternalLoginConfirmationViewModel { UserName = name });
        }

        private async Task&lt;IActionResult&gt; SpaExternalLogin(string returnUrl, string remoteError)
        {
            if (remoteError != null)
            {
                return new RedirectResult($&quot;{returnUrl}?e={remoteError}&quot;);
            }

            var info = await SignInManager.GetExternalLoginInfoAsync();
            if (info == null)
            {
                return new RedirectResult($&quot;{returnUrl}&quot;);
            }

            var name = info.Principal.FindFirstValue(ClaimTypes.Name);
            // Sign in the user with this external login provider if the user already has a login.
            var result = await SignInManager.ExternalLoginSignInAsync(info.LoginProvider, info.ProviderKey, isPersistent: false);
            if (result.Succeeded)
            {
                // Update any authentication tokens if login succeeded
                await SignInManager.UpdateExternalAuthenticationTokensAsync(info);
                
                var user = await UserManager.FindByLoginAsync(info.LoginProvider, info.ProviderKey);
                
                return new RedirectResult($&quot;{returnUrl}?u={user.UserName}&quot;);
            }

            // If the user does not have an account, then ask the user to create an account.
            return new RedirectResult($&quot;{returnUrl}?p={info.LoginProvider}&amp;u={name}&quot;);
        }

        //
        // POST: /Account/ExternalLoginConfirmation
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; ExternalLoginConfirmation(ExternalLoginConfirmationViewModel model, string returnUrl = null)
        {
            if (ModelState.IsValid)
            {
                // Get the information about the user from the external login provider
                var info = await SignInManager.GetExternalLoginInfoAsync();
                if (info == null)
                {
                    return View(&quot;ExternalLoginFailure&quot;);
                }
                var user = new ChatLeUser { UserName = model.UserName };
                var result = await UserManager.CreateAsync(user);
                if (result.Succeeded)
                {
                    result = await UserManager.AddLoginAsync(user, info);
                    if (result.Succeeded)
                    {
                        await SignInManager.SignInAsync(user, isPersistent: false);

                        // Update any authentication tokens as well
                        await SignInManager.UpdateExternalAuthenticationTokensAsync(info);

                        return RedirectToLocal(returnUrl);
                    }
                }
                AddErrors(result);
            }

            ViewData[&quot;ReturnUrl&quot;] = returnUrl;
            return View(model);
        }


        //
        // POST: /Account/SpaExternalLoginConfirmation
        [HttpPut]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;JsonResult&gt; SpaExternalLoginConfirmation([FromBody] ExternalLoginConfirmationViewModel model)
        {
            if (ModelState.IsValid)
            {
                // Get the information about the user from the external login provider
                var info = await SignInManager.GetExternalLoginInfoAsync();
                if (info == null)
                {
                    ModelState.AddModelError(&quot;NullInfo&quot;, &quot;External login info is null&quot;);
                }
                else
                {
                    var user = new ChatLeUser { UserName = model.UserName };
                    var result = await UserManager.CreateAsync(user);
                    if (result.Succeeded)
                    {
                        result = await UserManager.AddLoginAsync(user, info);
                        if (result.Succeeded)
                        {
                            await SignInManager.SignInAsync(user, isPersistent: false);

                            // Update any authentication tokens as well
                            await SignInManager.UpdateExternalAuthenticationTokensAsync(info);

                            return new JsonResult(&quot;OK&quot;);
                        }
                    }

                    AddErrors(result);
                }
            }

            return ReturnSpaError();
        }

        [HttpGet]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;bool&gt; Exists(string userName)
        {
            return await UserManager.FindByNameAsync(userName) != null;
        }

        //GET: /Manage/Manage
        [HttpGet]
        public async Task&lt;IActionResult&gt; Manage(ManageMessageId? message = null)
        {
            ViewData[&quot;StatusMessage&quot;] =
                message == ManageMessageId.RemoveLoginSuccess ? &quot;The external login was removed.&quot;
                : message == ManageMessageId.AddLoginSuccess ? &quot;The external login was added.&quot;
                : message == ManageMessageId.Error ? &quot;An error has occurred.&quot;
                : &quot;&quot;;

            var user = await GetCurrentUserAsync();
            var vm = await GetLogins(user);
            ViewData[&quot;ShowRemoveButton&quot;] = user.PasswordHash != null || vm.CurrentLogins.Count &gt; 1;
            DeleteExternalCookie();
            return View(vm);
        }

        //
        // POST: /Account/UpdatePassword
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; UpdatePassword(UpdatePasswordViewModel model)
        {
            ViewBag.ReturnUrl = Url.Action(&quot;Manage&quot;);
            if (ModelState.IsValid)
            {
                var user = await GetCurrentUserAsync();
                var result = await UserManager.ChangePasswordAsync(user, model.OldPassword, model.NewPassword);
                if (result.Succeeded)
                    return RedirectToAction(&quot;Manage&quot;, new { Message = ManageMessageId.ChangePasswordSuccess });
                else
                    AddErrors(result);
            }

            // If we got this far, something failed, redisplay form
            return View(model);
        }

        //
        // PUT: /Account/ChangePassword
        [HttpPut]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; ChangePassword([FromBody] UpdatePasswordViewModel model)
        {
            ViewBag.ReturnUrl = Url.Action(&quot;Manage&quot;);
            if (ModelState.IsValid)
            {
                var user = await GetCurrentUserAsync();
                var result = await UserManager.ChangePasswordAsync(user, model.OldPassword, model.NewPassword);
                if (result.Succeeded)
                    return new JsonResult(ManageMessageId.ChangePasswordSuccess);
                else
                    AddErrors(result);
            }

            return ReturnSpaError();
        }

        //
        // POST: /Account/SetPassword
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; SetPassword([FromBody] CreatePasswordViewModel model)
        {
            ViewBag.ReturnUrl = Url.Action(&quot;Manage&quot;);
            if (ModelState.IsValid)
            {
                var user = await GetCurrentUserAsync();
                var result = await UserManager.AddPasswordAsync(user, model.NewPassword);
                if (result.Succeeded)
                {
                    await SignInManager.SignInAsync(user, false);
                    return new JsonResult(ManageMessageId.ChangePasswordSuccess);
                }
                else
                    AddErrors(result);
            }

            return ReturnSpaError();
        }

        [HttpGet]
        public async Task&lt;ManageLoginsViewModel&gt; Logins()
        {
            var user = await GetCurrentUserAsync();
            return await GetLogins(user);
        }

        //
        // POST: /Manage/RemoveLogin
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; RemoveLogin(RemoveLoginViewModel account)
        {
            if (await InternalRemoveLogin(account))
            {
                return RedirectToAction(nameof(Manage), new { ManageMessageId.RemoveLoginSuccess });
            }
            return RedirectToAction(nameof(Manage));
        }

        [HttpDelete]
        [ValidateAntiForgeryToken]
        public async Task SpaRemoveLogin(RemoveLoginViewModel account)
        {
            await InternalRemoveLogin(account);
        }

        //
        // POST: /Manage/LinkLogin
        [HttpPost]
        [ValidateAntiForgeryToken]
        public IActionResult LinkLogin(string provider, string returnUrl = null)
        {
            // Request a redirect to the external login provider to link a login for the current user
            var redirectUrl = Url.Action(&quot;LinkLoginCallback&quot;, &quot;Account&quot;, new { ReturnUrl = returnUrl });
            var properties = SignInManager.ConfigureExternalAuthenticationProperties(provider, redirectUrl, UserManager.GetUserId(User));            
            return Challenge(properties, provider);
        }

        //
        // GET: /Manage/LinkLoginCallback
        [HttpGet]
        public async Task&lt;ActionResult&gt; LinkLoginCallback(string returnUrl = null)
        {
            var user = await GetCurrentUserAsync();

            if (returnUrl != null)
            {
                return await SpaLinkLogin(user, returnUrl);
            }

            if (user == null)
            {
                return View(&quot;Error&quot;);
            }
            var info = await SignInManager.GetExternalLoginInfoAsync(await UserManager.GetUserIdAsync(user));
            if (info == null)
            {
                return RedirectToAction(nameof(Manage), new { Message = ManageMessageId.Error });
            }
            var result = await UserManager.AddLoginAsync(user, info);
            var message = result.Succeeded ? ManageMessageId.AddLoginSuccess : ManageMessageId.Error;
            return RedirectToAction(nameof(Manage), new { Message = message });
        }

        #region Helpers

        private async Task&lt;ActionResult&gt; SpaLinkLogin(ChatLeUser user, string returnUrl)
        {
            if (user == null)
            {
                return new RedirectResult($&quot;{returnUrl}&amp;r=no-user&quot;);
            }

            var info = await SignInManager.GetExternalLoginInfoAsync(await UserManager.GetUserIdAsync(user));
            if (info == null)
            {
                return new RedirectResult($&quot;{returnUrl}&amp;r=no-info&quot;);
            }

            var result = await UserManager.AddLoginAsync(user, info);
            var message = result.Succeeded ? &quot;succeed&quot; : &quot;error&quot;;
            return new RedirectResult($&quot;{returnUrl}&amp;r={message}&quot;);
        }

        private void DeleteExternalCookie()
        {
            Response.Cookies.Delete(&quot;Identity.External&quot;);
        }

        private async Task&lt;ManageLoginsViewModel&gt; GetLogins(ChatLeUser user)
        {
            var userLogins = await UserManager.GetLoginsAsync(user);
            var otherLogins = (await SignInManager.GetExternalAuthenticationSchemesAsync())
                .Where(auth =&gt; userLogins.All(ul =&gt; auth.Name != ul.LoginProvider))
                .Select(auth =&gt; new AuthenticationDescription { AuthenticationScheme = auth.Name, DisplayName = auth.DisplayName })
                .ToList();

            return new ManageLoginsViewModel
            {
                CurrentLogins = userLogins,
                OtherLogins = otherLogins,
                Passwords = user.PasswordHash != null ? new UpdatePasswordViewModel() : null                
            };
        }

        private async Task&lt;bool&gt; InternalRemoveLogin(RemoveLoginViewModel account)
        {
            var user = await GetCurrentUserAsync();
            if (user != null)
            {
                var result = await UserManager.RemoveLoginAsync(user, account.LoginProvider, account.ProviderKey);
                if (result.Succeeded)
                {
                    await SignInManager.SignInAsync(user, isPersistent: false);
                    return true;
                }
            }

            return false;
        }

        private JsonResult ReturnSpaError()
        {
            Response.StatusCode = (int)HttpStatusCode.BadRequest;
            return new JsonResult(ModelState.Root.Children);            
        }

        private async Task SignOut()
        {
            var user = await GetCurrentUserAsync();
			if (user != null)
			{
                try
                {
                    user.IsGuess = await ChatManager.IsGuess(user);
                    await HubContext.Clients.All.SendAsync(&quot;userDisconnected&quot;, new { id = user.UserName, isRemoved = user.IsGuess });
                    if (user.IsGuess)
                    {
                        await ChatManager.RemoveUserAsync(user);
                    }
                }
                catch(Exception e)
                {
                    Logger.LogError(e, &quot;AccountController Signout error . {0}&quot;, e.Message);
                }
            }
            await SignInManager.SignOutAsync();
        }

        private void AddErrors(IdentityResult result)
        {
            foreach (var error in result.Errors)
                ModelState.AddModelError(error.Code, error.Description);
        }

        private async Task&lt;ChatLeUser&gt; GetCurrentUserAsync()
        {
            return await ChatManager.Store.FindUserByNameAsync(HttpContext.User.Identity.Name);
        }

        private IActionResult RedirectToLocal(string returnUrl)
        {
            if (Url.IsLocalUrl(returnUrl))
                return Redirect(returnUrl);
            else
                return RedirectToAction(&quot;Index&quot;, &quot;Home&quot;);
        }

        public enum ManageMessageId
        {
            ChangePasswordSuccess,
            Error,
            AddLoginSuccess,
            RemoveLoginSuccess
        }
        #endregion
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[25,9,29,42,1],[30,9,30,10,1],[31,13,31,39,1],[32,13,32,43,1],[33,13,33,39,1],[34,13,34,70,1],[35,13,35,37,1],[36,9,36,10,1],[38,54,38,58,1],[38,59,38,71,1],[40,58,40,62,1],[40,63,40,75,1],[42,120,42,124,1],[42,125,42,137,1],[44,33,44,37,0],[44,38,44,50,1],[46,50,46,54,1],[46,55,46,67,1],[52,9,52,10,1],[53,13,53,43,1],[54,13,54,36,1],[55,13,55,51,1],[56,9,56,10,1],[64,9,64,10,1],[65,13,65,36,1],[66,13,66,14,1],[67,17,67,151,1],[69,17,69,44,1],[70,21,70,55,1],[72,17,72,79,1],[73,17,73,36,1],[77,13,77,78,0],[78,9,78,10,1],[86,9,86,10,0],[87,13,87,36,0],[88,13,88,14,0],[89,17,89,151,0],[91,17,91,44,0],[92,21,92,67,0],[94,17,94,100,0],[95,13,95,14,0],[97,13,97,37,0],[98,9,98,10,0],[106,9,106,10,1],[107,13,107,36,1],[108,13,108,14,1],[109,17,109,73,1],[111,17,111,66,1],[113,17,113,38,1],[114,17,114,18,1],[115,21,115,80,1],[116,21,116,62,1],[119,21,119,39,1],[120,13,120,14,1],[123,13,123,78,1],[124,9,124,10,1],[131,9,131,10,0],[132,13,132,36,0],[133,13,133,14,0],[134,17,134,73,0],[135,17,135,66,0],[136,17,136,38,0],[137,17,137,18,0],[138,21,138,80,0],[139,21,139,61,0],[142,17,142,18,0],[143,21,143,39,0],[144,17,144,18,0],[145,13,145,14,0],[147,13,147,37,0],[148,9,148,10,0],[155,9,155,10,1],[156,13,156,27,1],[157,9,157,10,1],[165,9,165,10,1],[166,13,166,36,1],[167,13,167,14,1],[168,17,168,73,1],[169,17,169,82,1],[171,17,171,38,1],[172,17,172,18,1],[173,21,173,80,1],[174,21,174,62,1],[177,21,177,39,1],[178,13,178,14,1],[181,13,181,32,1],[182,9,182,10,1],[189,9,189,10,1],[190,13,190,29,1],[191,4,191,75,1],[192,9,192,10,1],[199,9,199,10,0],[200,13,200,29,0],[201,9,201,10,0],[207,73,207,74,0],[208,13,208,93,0],[208,93,212,18,0],[212,18,212,20,0],[208,13,212,20,0],[213,9,213,10,0],[221,9,221,10,0],[223,13,223,109,0],[224,13,224,138,0],[225,13,225,52,0],[226,9,226,10,0],[233,9,233,10,0],[234,13,234,35,0],[235,13,235,14,0],[236,17,236,71,0],[239,13,239,37,0],[240,13,240,14,0],[241,17,241,104,0],[242,17,242,44,0],[245,13,245,72,0],[246,13,246,30,0],[247,13,247,14,0],[248,17,248,56,0],[252,13,252,130,0],[253,13,253,34,0],[254,13,254,14,0],[256,17,256,83,0],[258,17,258,51,0],[262,13,262,60,0],[263,13,263,71,0],[265,13,265,114,0],[266,9,266,10,0],[269,9,269,10,0],[270,13,270,37,0],[271,13,271,14,0],[272,17,272,75,0],[275,13,275,72,0],[276,13,276,30,0],[277,13,277,14,0],[278,17,278,59,0],[281,13,281,71,0],[283,13,283,130,0],[284,13,284,34,0],[285,13,285,14,0],[287,17,287,83,0],[289,17,289,101,0],[291,17,291,77,0],[295,13,295,87,0],[296,9,296,10,0],[304,9,304,10,0],[305,13,305,36,0],[306,13,306,14,0],[308,17,308,76,0],[309,17,309,34,0],[310,17,310,18,0],[311,21,311,57,0],[313,17,313,73,0],[314,17,314,66,0],[315,17,315,38,0],[316,17,316,18,0],[317,21,317,74,0],[318,21,318,42,0],[319,21,319,22,0],[320,25,320,84,0],[323,25,323,91,0],[325,25,325,59,0],[327,17,327,18,0],[328,17,328,35,0],[329,13,329,14,0],[331,13,331,47,0],[332,13,332,32,0],[333,9,333,10,0],[342,9,342,10,0],[343,13,343,36,0],[344,13,344,14,0],[346,17,346,76,0],[347,17,347,34,0],[348,17,348,18,0],[349,21,349,89,0],[350,17,350,18,0],[352,17,352,18,0],[353,21,353,77,0],[354,21,354,70,0],[355,21,355,42,0],[356,21,356,22,0],[357,25,357,78,0],[358,25,358,46,0],[359,25,359,26,0],[360,29,360,88,0],[363,29,363,95,0],[365,29,365,57,0],[367,21,367,22,0],[369,21,369,39,0],[370,17,370,18,0],[371,13,371,14,0],[373,13,373,37,0],[374,9,374,10,0],[380,9,380,10,0],[381,13,381,72,0],[382,9,382,10,0],[387,9,387,10,1],[388,13,392,22,1],[394,13,394,52,1],[395,13,395,44,1],[396,13,396,100,1],[397,13,397,36,1],[398,13,398,29,1],[399,9,399,10,1],[406,9,406,10,1],[407,13,407,54,1],[408,13,408,36,1],[409,13,409,14,1],[410,17,410,56,1],[411,17,411,112,1],[412,17,412,38,1],[413,21,413,112,1],[415,21,415,39,1],[416,13,416,14,1],[419,13,419,32,1],[420,9,420,10,1],[427,9,427,10,0],[428,13,428,54,0],[429,13,429,36,0],[430,13,430,14,0],[431,17,431,56,0],[432,17,432,112,0],[433,17,433,38,0],[434,21,434,82,0],[436,21,436,39,0],[437,13,437,14,0],[439,13,439,37,0],[440,9,440,10,0],[447,9,447,10,0],[448,13,448,54,0],[449,13,449,36,0],[450,13,450,14,0],[451,17,451,56,0],[452,17,452,90,0],[453,17,453,38,0],[454,17,454,18,0],[455,21,455,66,0],[456,21,456,82,0],[459,21,459,39,0],[460,13,460,14,0],[462,13,462,37,0],[463,9,463,10,0],[467,9,467,10,0],[468,13,468,52,0],[469,13,469,42,0],[470,9,470,10,0],[477,9,477,10,0],[478,13,478,52,0],[479,13,479,14,0],[480,17,480,101,0],[482,13,482,53,0],[483,9,483,10,0],[488,9,488,10,0],[489,13,489,48,0],[490,9,490,10,0],[497,9,497,10,0],[499,13,499,105,0],[500,13,500,138,0],[501,13,501,52,0],[502,9,502,10,0],[508,9,508,10,0],[509,13,509,52,0],[511,13,511,35,0],[512,13,512,14,0],[513,17,513,60,0],[516,13,516,30,0],[517,13,517,14,0],[518,17,518,38,0],[520,13,520,110,0],[521,13,521,30,0],[522,13,522,14,0],[523,17,523,98,0],[525,13,525,70,0],[526,13,526,102,0],[527,13,527,80,0],[528,9,528,10,0],[533,9,533,10,0],[534,13,534,30,0],[535,13,535,14,0],[536,17,536,69,0],[539,13,539,110,0],[540,13,540,30,0],[541,13,541,14,0],[542,17,542,69,0],[545,13,545,70,0],[546,13,546,66,0],[547,13,547,67,0],[548,9,548,10,0],[551,9,551,10,1],[552,13,552,58,1],[553,9,553,10,1],[556,9,556,10,1],[557,13,557,69,1],[558,13,559,32,1],[559,32,559,53,0],[559,53,559,82,0],[559,82,559,83,0],[559,32,559,83,0],[559,83,560,33,1],[560,33,560,131,0],[560,131,561,27,1],[558,13,561,27,1],[563,13,568,15,1],[569,9,569,10,1],[572,9,572,10,0],[573,13,573,52,0],[574,13,574,30,0],[575,13,575,14,0],[576,17,576,115,0],[577,17,577,38,0],[578,17,578,18,0],[579,21,579,80,0],[580,21,580,33,0],[582,13,582,14,0],[584,13,584,26,0],[585,9,585,10,0],[588,9,588,10,0],[589,13,589,66,0],[590,13,590,61,0],[591,9,591,10,0],[594,9,594,10,1],[595,13,595,52,1],[596,4,596,21,1],[597,4,597,5,1],[599,17,599,18,1],[600,21,600,68,1],[601,21,601,134,1],[602,21,602,38,1],[603,21,603,22,0],[604,25,604,65,0],[605,21,605,22,0],[606,17,606,18,1],[607,17,607,35,0],[608,17,608,18,0],[609,21,609,92,0],[610,17,610,18,0],[611,13,611,14,1],[612,13,612,48,1],[613,9,613,10,1],[616,9,616,10,1],[617,13,617,20,1],[617,22,617,31,1],[617,32,617,34,1],[617,35,617,48,1],[618,17,618,73,1],[619,9,619,10,1],[622,9,622,10,1],[623,13,623,96,1],[624,9,624,10,1],[627,9,627,10,1],[628,13,628,43,1],[629,17,629,44,0],[631,17,631,58,1],[632,9,632,10,1]]);
    </script>
  </body>
</html>