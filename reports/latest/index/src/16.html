<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\projects\chatle\src\chatle\Controllers\AccountController.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using ChatLe.Hubs;
using ChatLe.Models;
using ChatLe.ViewModels;
using System.Net;
using ChatLe.Repository.Identity;
using Microsoft.AspNetCore.Http;
using System.Security.Claims;
using System.Linq;
using Microsoft.Extensions.Logging;
using System.Collections.Generic;
using Microsoft.AspNetCore.SignalR;
using Microsoft.AspNetCore.Http.Authentication;
using Microsoft.AspNetCore.Authentication;

namespace ChatLe.Controllers
{
    [Authorize]
    public class AccountController : Controller
    {
        public AccountController(UserManager&lt;ChatLeUser&gt; userManager, 
            SignInManager signInManager,
            IChatManager&lt;string, ChatLeUser, Conversation, Attendee, Message, NotificationConnection&gt; chatManager,
            IHubContext&lt;ChatHub&gt; hubContext,
            ILoggerFactory loggerFactory)
        {
            UserManager = userManager;
            SignInManager = signInManager;
            ChatManager = chatManager;
            Logger = loggerFactory.CreateLogger&lt;AccountController&gt;();
            HubContext = hubContext;
        }

        public UserManager&lt;ChatLeUser&gt; UserManager { get; private set; }

        public SignInManager&lt;ChatLeUser&gt; SignInManager { get; private set; }

        public IChatManager&lt;string, ChatLeUser, Conversation, Attendee, Message, NotificationConnection&gt; ChatManager { get; private set; }

        public ILogger Logger { get; private set; }

        public IHubContext&lt;ChatHub&gt; HubContext { get; private set; }

        // GET: /Account/Index
        [HttpGet]
        [AllowAnonymous]
        public IActionResult Index(string returnUrl = null, string reason = null)
        {
            ViewBag.ReturnUrl = returnUrl;
            DeleteExternalCookie();
            return View(new LoginPageViewModel());
        }

        //
        // POST: /Account/Login
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; Login(LoginViewModel model, string returnUrl = null)
        {
            if (ModelState.IsValid)
            {
                var signInStatus = await SignInManager.PasswordSignInAsync(model.UserName, model.Password, model.RememberMe, lockoutOnFailure: false);

                if (signInStatus.Succeeded)
                    return RedirectToLocal(returnUrl);

                ModelState.AddModelError(&quot;&quot;, &quot;Invalid username or password.&quot;);
                return View(model);
            }

            // If we got this far, something failed, redisplay form
            return View(&quot;Index&quot;, new LoginPageViewModel() { Login = model });
        }

        //
        // POST: /Account/SpaLogin
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; SpaLogin([FromBody] LoginViewModel model)
        {
            if (ModelState.IsValid)
            {
                var signInStatus = await SignInManager.PasswordSignInAsync(model.UserName, model.Password, model.RememberMe, lockoutOnFailure: false);

                if (signInStatus.Succeeded)
                    return new JsonResult(signInStatus.Succeeded);

                ModelState.AddModelError(&quot;InvalidUserOrPAssword&quot;, &quot;Invalid username or password.&quot;);                
            }

            return ReturnSpaError();
        }

        //
        // POST: /Account/Guess
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; Guess(GuessViewModel model, string returnUrl = null)
        {
            if (ModelState.IsValid)
            {
                var user = new ChatLeUser { UserName = model.UserName };

                var result = await UserManager.CreateAsync(user);
                
                if (result.Succeeded)
                {
                    await SignInManager.SignInAsync(user, isPersistent: false);
                    return RedirectToAction(&quot;Index&quot;, &quot;Home&quot;);
                }
                else
                    AddErrors(result);
            }

            // If we got this far, something failed, redisplay form
            return View(&quot;Index&quot;, new LoginPageViewModel() { Guess = model });
        }

        //
        // POST: /Account/SpaGuess
        [HttpPost]
        [AllowAnonymous]
        public async Task&lt;JsonResult&gt; SpaGuess([FromBody] GuessViewModel model)
        {
            if (ModelState.IsValid)
            {
                var user = new ChatLeUser { UserName = model.UserName };
                var result = await UserManager.CreateAsync(user);
                if (result.Succeeded)
                {
                    await SignInManager.SignInAsync(user, isPersistent: false);
                    return new JsonResult(result.Succeeded);
                }
                else
                {
                    AddErrors(result);
                }
            }

            return ReturnSpaError();
        }

        //
        // GET: /Account/Register
        [AllowAnonymous]
        [HttpGet]
        public IActionResult Register()
        {
            return View();
        }

        //
        // POST: /Account/Register
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; Register(RegisterViewModel model)
        {
            if (ModelState.IsValid)
            {
                var user = new ChatLeUser { UserName = model.UserName };
                var result = await UserManager.CreateAsync(user, model.Password);

                if (result.Succeeded)
                {
                    await SignInManager.SignInAsync(user, isPersistent: false);
                    return RedirectToAction(&quot;Index&quot;, &quot;Home&quot;);
                }
                else
                    AddErrors(result);
            }

            // If we got this far, something failed, redisplay form
            return View(model);
        }

        //
        // POST: /Account/LogOff
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; LogOff(string reason = null)
        {
            await SignOut();
			return RedirectToAction(&quot;Index&quot;, routeValues: new { Reason = reason });
        }

        //
        // POST: /Account/SpaLogOff
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task SpaLogOff(string reason = null)
        {
            await SignOut();        
        }

        //
        // GET: /Account/ExternalLoginCallback
        [HttpGet]
        [AllowAnonymous]
        public IEnumerable&lt;ExternalLoginProvider&gt; GetExternalProviders(){
            return SignInManager.GetExternalAuthenticationSchemesAsync().Result.Select(p =&gt; new ExternalLoginProvider
                { 
                    DisplayName = p.DisplayName,
                    AuthenticationScheme = p.Name  
                });
        }

        //
        // POST: /Account/ExternalLogin
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public IActionResult ExternalLogin(string provider, string returnUrl = null)
        {
            // Request a redirect to the external login provider.
            var redirectUrl = Url.Action(&quot;ExternalLoginCallback&quot;, &quot;Account&quot;, new { ReturnUrl = returnUrl });
            var properties = SignInManager.ConfigureExternalAuthenticationProperties(provider, redirectUrl, UserManager.GetUserId(User));
            return Challenge(properties, provider);
        }

        //
        // GET: /Account/ExternalLoginCallback
        [HttpGet]
        [AllowAnonymous]
        public async Task&lt;IActionResult&gt; ExternalLoginCallback(string returnUrl = null, string remoteError = null)
        {
            if (returnUrl != null)
            {
                return await SpaExternalLogin(returnUrl, remoteError);
            }

            if (remoteError != null)
            {
                ModelState.AddModelError(string.Empty, $&quot;Error from external provider: {remoteError}&quot;);
                return View(nameof(Login));
            }

            var info = await SignInManager.GetExternalLoginInfoAsync();
            if (info == null)
            {
                return RedirectToAction(nameof(Index));
            }

            // Sign in the user with this external login provider if the user already has a login.
            var result = await SignInManager.ExternalLoginSignInAsync(info.LoginProvider, info.ProviderKey, isPersistent: false);
            if (result.Succeeded)
            {
                // Update any authentication tokens if login succeeded
                await SignInManager.UpdateExternalAuthenticationTokensAsync(info);

                return RedirectToLocal(returnUrl);
            }

            // If the user does not have an account, then ask the user to create an account.
            ViewData[&quot;LoginProvider&quot;] = info.LoginProvider;
            var name = info.Principal.FindFirstValue(ClaimTypes.Name);

            return View(&quot;ExternalLoginConfirmation&quot;, new ExternalLoginConfirmationViewModel { UserName = name });
        }

        private async Task&lt;IActionResult&gt; SpaExternalLogin(string returnUrl, string remoteError)
        {
            if (remoteError != null)
            {
                return new RedirectResult($&quot;{returnUrl}?e={remoteError}&quot;);
            }

            var info = await SignInManager.GetExternalLoginInfoAsync();
            if (info == null)
            {
                return new RedirectResult($&quot;{returnUrl}&quot;);
            }

            var name = info.Principal.FindFirstValue(ClaimTypes.Name);
            // Sign in the user with this external login provider if the user already has a login.
            var result = await SignInManager.ExternalLoginSignInAsync(info.LoginProvider, info.ProviderKey, isPersistent: false);
            if (result.Succeeded)
            {
                // Update any authentication tokens if login succeeded
                await SignInManager.UpdateExternalAuthenticationTokensAsync(info);
                
                var user = await UserManager.FindByLoginAsync(info.LoginProvider, info.ProviderKey);
                
                return new RedirectResult($&quot;{returnUrl}?u={user.UserName}&quot;);
            }

            // If the user does not have an account, then ask the user to create an account.
            return new RedirectResult($&quot;{returnUrl}?p={info.LoginProvider}&amp;u={name}&quot;);
        }

        //
        // POST: /Account/ExternalLoginConfirmation
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; ExternalLoginConfirmation(ExternalLoginConfirmationViewModel model, string returnUrl = null)
        {
            if (ModelState.IsValid)
            {
                // Get the information about the user from the external login provider
                var info = await SignInManager.GetExternalLoginInfoAsync();
                if (info == null)
                {
                    return View(&quot;ExternalLoginFailure&quot;);
                }
                var user = new ChatLeUser { UserName = model.UserName };
                var result = await UserManager.CreateAsync(user);
                if (result.Succeeded)
                {
                    result = await UserManager.AddLoginAsync(user, info);
                    if (result.Succeeded)
                    {
                        await SignInManager.SignInAsync(user, isPersistent: false);

                        // Update any authentication tokens as well
                        await SignInManager.UpdateExternalAuthenticationTokensAsync(info);

                        return RedirectToLocal(returnUrl);
                    }
                }
                AddErrors(result);
            }

            ViewData[&quot;ReturnUrl&quot;] = returnUrl;
            return View(model);
        }


        //
        // POST: /Account/SpaExternalLoginConfirmation
        [HttpPut]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;JsonResult&gt; SpaExternalLoginConfirmation([FromBody] ExternalLoginConfirmationViewModel model)
        {
            if (ModelState.IsValid)
            {
                // Get the information about the user from the external login provider
                var info = await SignInManager.GetExternalLoginInfoAsync();
                if (info == null)
                {
                    ModelState.AddModelError(&quot;NullInfo&quot;, &quot;External login info is null&quot;);
                }
                else
                {
                    var user = new ChatLeUser { UserName = model.UserName };
                    var result = await UserManager.CreateAsync(user);
                    if (result.Succeeded)
                    {
                        result = await UserManager.AddLoginAsync(user, info);
                        if (result.Succeeded)
                        {
                            await SignInManager.SignInAsync(user, isPersistent: false);

                            // Update any authentication tokens as well
                            await SignInManager.UpdateExternalAuthenticationTokensAsync(info);

                            return new JsonResult(&quot;OK&quot;);
                        }
                    }

                    AddErrors(result);
                }
            }

            return ReturnSpaError();
        }

        [HttpGet]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;bool&gt; Exists(string userName)
        {
            return await UserManager.FindByNameAsync(userName) != null;
        }

        //GET: /Manage/Manage
        [HttpGet]
        public async Task&lt;IActionResult&gt; Manage(ManageMessageId? message = null)
        {
            ViewData[&quot;StatusMessage&quot;] =
                message == ManageMessageId.RemoveLoginSuccess ? &quot;The external login was removed.&quot;
                : message == ManageMessageId.AddLoginSuccess ? &quot;The external login was added.&quot;
                : message == ManageMessageId.Error ? &quot;An error has occurred.&quot;
                : &quot;&quot;;

            var user = await GetCurrentUserAsync();
            var vm = await GetLogins(user);
            ViewData[&quot;ShowRemoveButton&quot;] = user.PasswordHash != null || vm.CurrentLogins.Count &gt; 1;
            DeleteExternalCookie();
            return View(vm);
        }

        //
        // POST: /Account/UpdatePassword
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; UpdatePassword(UpdatePasswordViewModel model)
        {
            ViewBag.ReturnUrl = Url.Action(&quot;Manage&quot;);
            if (ModelState.IsValid)
            {
                var user = await GetCurrentUserAsync();
                var result = await UserManager.ChangePasswordAsync(user, model.OldPassword, model.NewPassword);
                if (result.Succeeded)
                    return RedirectToAction(&quot;Manage&quot;, new { Message = ManageMessageId.ChangePasswordSuccess });
                else
                    AddErrors(result);
            }

            // If we got this far, something failed, redisplay form
            return View(model);
        }

        //
        // PUT: /Account/ChangePassword
        [HttpPut]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; ChangePassword([FromBody] UpdatePasswordViewModel model)
        {
            ViewBag.ReturnUrl = Url.Action(&quot;Manage&quot;);
            if (ModelState.IsValid)
            {
                var user = await GetCurrentUserAsync();
                var result = await UserManager.ChangePasswordAsync(user, model.OldPassword, model.NewPassword);
                if (result.Succeeded)
                    return new JsonResult(ManageMessageId.ChangePasswordSuccess);
                else
                    AddErrors(result);
            }

            return ReturnSpaError();
        }

        //
        // POST: /Account/SetPassword
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; SetPassword([FromBody] CreatePasswordViewModel model)
        {
            ViewBag.ReturnUrl = Url.Action(&quot;Manage&quot;);
            if (ModelState.IsValid)
            {
                var user = await GetCurrentUserAsync();
                var result = await UserManager.AddPasswordAsync(user, model.NewPassword);
                if (result.Succeeded)
                {
                    await SignInManager.SignInAsync(user, false);
                    return new JsonResult(ManageMessageId.ChangePasswordSuccess);
                }
                else
                    AddErrors(result);
            }

            return ReturnSpaError();
        }

        [HttpGet]
        public async Task&lt;ManageLoginsViewModel&gt; Logins()
        {
            var user = await GetCurrentUserAsync();
            return await GetLogins(user);
        }

        //
        // POST: /Manage/RemoveLogin
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; RemoveLogin(RemoveLoginViewModel account)
        {
            if (await InternalRemoveLogin(account))
            {
                return RedirectToAction(nameof(Manage), new { ManageMessageId.RemoveLoginSuccess });
            }
            return RedirectToAction(nameof(Manage));
        }

        [HttpDelete]
        [ValidateAntiForgeryToken]
        public async Task SpaRemoveLogin(RemoveLoginViewModel account)
        {
            await InternalRemoveLogin(account);
        }

        //
        // POST: /Manage/LinkLogin
        [HttpPost]
        [ValidateAntiForgeryToken]
        public IActionResult LinkLogin(string provider, string returnUrl = null)
        {
            // Request a redirect to the external login provider to link a login for the current user
            var redirectUrl = Url.Action(&quot;LinkLoginCallback&quot;, &quot;Account&quot;, new { ReturnUrl = returnUrl });
            var properties = SignInManager.ConfigureExternalAuthenticationProperties(provider, redirectUrl, UserManager.GetUserId(User));            
            return Challenge(properties, provider);
        }

        //
        // GET: /Manage/LinkLoginCallback
        [HttpGet]
        public async Task&lt;ActionResult&gt; LinkLoginCallback(string returnUrl = null)
        {
            var user = await GetCurrentUserAsync();

            if (returnUrl != null)
            {
                return await SpaLinkLogin(user, returnUrl);
            }

            if (user == null)
            {
                return View(&quot;Error&quot;);
            }
            var info = await SignInManager.GetExternalLoginInfoAsync(await UserManager.GetUserIdAsync(user));
            if (info == null)
            {
                return RedirectToAction(nameof(Manage), new { Message = ManageMessageId.Error });
            }
            var result = await UserManager.AddLoginAsync(user, info);
            var message = result.Succeeded ? ManageMessageId.AddLoginSuccess : ManageMessageId.Error;
            return RedirectToAction(nameof(Manage), new { Message = message });
        }

        #region Helpers

        private async Task&lt;ActionResult&gt; SpaLinkLogin(ChatLeUser user, string returnUrl)
        {
            if (user == null)
            {
                return new RedirectResult($&quot;{returnUrl}&amp;r=no-user&quot;);
            }

            var info = await SignInManager.GetExternalLoginInfoAsync(await UserManager.GetUserIdAsync(user));
            if (info == null)
            {
                return new RedirectResult($&quot;{returnUrl}&amp;r=no-info&quot;);
            }

            var result = await UserManager.AddLoginAsync(user, info);
            var message = result.Succeeded ? &quot;succeed&quot; : &quot;error&quot;;
            return new RedirectResult($&quot;{returnUrl}&amp;r={message}&quot;);
        }

        private void DeleteExternalCookie()
        {
            Response.Cookies.Delete(&quot;Identity.External&quot;);
        }

        private async Task&lt;ManageLoginsViewModel&gt; GetLogins(ChatLeUser user)
        {
            var userLogins = await UserManager.GetLoginsAsync(user);
            var otherLogins = (await SignInManager.GetExternalAuthenticationSchemesAsync())
                .Where(auth =&gt; userLogins.All(ul =&gt; auth.Name != ul.LoginProvider))
                .Select(auth =&gt; new AuthenticationDescription { AuthenticationScheme = auth.Name, DisplayName = auth.DisplayName })
                .ToList();

            return new ManageLoginsViewModel
            {
                CurrentLogins = userLogins,
                OtherLogins = otherLogins,
                Passwords = user.PasswordHash != null ? new UpdatePasswordViewModel() : null                
            };
        }

        private async Task&lt;bool&gt; InternalRemoveLogin(RemoveLoginViewModel account)
        {
            var user = await GetCurrentUserAsync();
            if (user != null)
            {
                var result = await UserManager.RemoveLoginAsync(user, account.LoginProvider, account.ProviderKey);
                if (result.Succeeded)
                {
                    await SignInManager.SignInAsync(user, isPersistent: false);
                    return true;
                }
            }

            return false;
        }

        private JsonResult ReturnSpaError()
        {
            Response.StatusCode = (int)HttpStatusCode.BadRequest;
            return new JsonResult(ModelState.Root.Children);            
        }

        private async Task SignOut()
        {
            var user = await GetCurrentUserAsync();
			if (user != null)
			{
                var isGuess = await ChatManager.IsGuess(user);
                await HubContext.Clients.All.InvokeAsync(&quot;userDisconnected&quot;, new { id = user.UserName, isRemoved = isGuess });
				if (isGuess)
				{
					await ChatManager.RemoveUserAsync(user);
				}
			}
            await SignInManager.SignOutAsync();
        }

        private void AddErrors(IdentityResult result)
        {
            foreach (var error in result.Errors)
                ModelState.AddModelError(error.Code, error.Description);
        }

        private async Task&lt;ChatLeUser&gt; GetCurrentUserAsync()
        {
            return await ChatManager.Store.FindUserByNameAsync(HttpContext.User.Identity.Name);
        }

        private IActionResult RedirectToLocal(string returnUrl)
        {
            if (Url.IsLocalUrl(returnUrl))
                return Redirect(returnUrl);
            else
                return RedirectToAction(&quot;Index&quot;, &quot;Home&quot;);
        }

        public enum ManageMessageId
        {
            ChangePasswordSuccess,
            Error,
            AddLoginSuccess,
            RemoveLoginSuccess
        }
        #endregion
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[24,9,28,42,1],[29,9,29,10,1],[30,13,30,39,1],[31,13,31,43,1],[32,13,32,39,1],[33,13,33,70,1],[34,13,34,37,1],[35,9,35,10,1],[37,54,37,58,1],[37,59,37,71,1],[39,58,39,62,1],[39,63,39,75,1],[41,120,41,124,1],[41,125,41,137,1],[43,33,43,37,0],[43,38,43,50,1],[45,50,45,54,1],[45,55,45,67,1],[51,9,51,10,1],[52,13,52,43,1],[53,13,53,36,1],[54,13,54,51,1],[55,9,55,10,1],[63,9,63,10,1],[64,13,64,36,1],[65,13,65,14,1],[66,17,66,151,1],[68,17,68,44,1],[69,21,69,55,1],[71,17,71,79,1],[72,17,72,36,1],[76,13,76,78,0],[77,9,77,10,1],[85,9,85,10,0],[86,13,86,36,0],[87,13,87,14,0],[88,17,88,151,0],[90,17,90,44,0],[91,21,91,67,0],[93,17,93,100,0],[94,13,94,14,0],[96,13,96,37,0],[97,9,97,10,0],[105,9,105,10,1],[106,13,106,36,1],[107,13,107,14,1],[108,17,108,73,1],[110,17,110,66,1],[112,17,112,38,1],[113,17,113,18,1],[114,21,114,80,1],[115,21,115,62,1],[118,21,118,39,1],[119,13,119,14,1],[122,13,122,78,1],[123,9,123,10,1],[130,9,130,10,0],[131,13,131,36,0],[132,13,132,14,0],[133,17,133,73,0],[134,17,134,66,0],[135,17,135,38,0],[136,17,136,18,0],[137,21,137,80,0],[138,21,138,61,0],[141,17,141,18,0],[142,21,142,39,0],[143,17,143,18,0],[144,13,144,14,0],[146,13,146,37,0],[147,9,147,10,0],[154,9,154,10,1],[155,13,155,27,1],[156,9,156,10,1],[164,9,164,10,1],[165,13,165,36,1],[166,13,166,14,1],[167,17,167,73,1],[168,17,168,82,1],[170,17,170,38,1],[171,17,171,18,1],[172,21,172,80,1],[173,21,173,62,1],[176,21,176,39,1],[177,13,177,14,1],[180,13,180,32,1],[181,9,181,10,1],[188,9,188,10,1],[189,13,189,29,1],[190,4,190,75,1],[191,9,191,10,1],[198,9,198,10,0],[199,13,199,29,0],[200,9,200,10,0],[206,73,206,74,0],[207,13,207,93,0],[207,93,211,18,0],[211,18,211,20,0],[207,13,211,20,0],[212,9,212,10,0],[220,9,220,10,0],[222,13,222,109,0],[223,13,223,138,0],[224,13,224,52,0],[225,9,225,10,0],[232,9,232,10,0],[233,13,233,35,0],[234,13,234,14,0],[235,17,235,71,0],[238,13,238,37,0],[239,13,239,14,0],[240,17,240,104,0],[241,17,241,44,0],[244,13,244,72,0],[245,13,245,30,0],[246,13,246,14,0],[247,17,247,56,0],[251,13,251,130,0],[252,13,252,34,0],[253,13,253,14,0],[255,17,255,83,0],[257,17,257,51,0],[261,13,261,60,0],[262,13,262,71,0],[264,13,264,114,0],[265,9,265,10,0],[268,9,268,10,0],[269,13,269,37,0],[270,13,270,14,0],[271,17,271,75,0],[274,13,274,72,0],[275,13,275,30,0],[276,13,276,14,0],[277,17,277,59,0],[280,13,280,71,0],[282,13,282,130,0],[283,13,283,34,0],[284,13,284,14,0],[286,17,286,83,0],[288,17,288,101,0],[290,17,290,77,0],[294,13,294,87,0],[295,9,295,10,0],[303,9,303,10,0],[304,13,304,36,0],[305,13,305,14,0],[307,17,307,76,0],[308,17,308,34,0],[309,17,309,18,0],[310,21,310,57,0],[312,17,312,73,0],[313,17,313,66,0],[314,17,314,38,0],[315,17,315,18,0],[316,21,316,74,0],[317,21,317,42,0],[318,21,318,22,0],[319,25,319,84,0],[322,25,322,91,0],[324,25,324,59,0],[326,17,326,18,0],[327,17,327,35,0],[328,13,328,14,0],[330,13,330,47,0],[331,13,331,32,0],[332,9,332,10,0],[341,9,341,10,0],[342,13,342,36,0],[343,13,343,14,0],[345,17,345,76,0],[346,17,346,34,0],[347,17,347,18,0],[348,21,348,89,0],[349,17,349,18,0],[351,17,351,18,0],[352,21,352,77,0],[353,21,353,70,0],[354,21,354,42,0],[355,21,355,22,0],[356,25,356,78,0],[357,25,357,46,0],[358,25,358,26,0],[359,29,359,88,0],[362,29,362,95,0],[364,29,364,57,0],[366,21,366,22,0],[368,21,368,39,0],[369,17,369,18,0],[370,13,370,14,0],[372,13,372,37,0],[373,9,373,10,0],[379,9,379,10,0],[380,13,380,72,0],[381,9,381,10,0],[386,9,386,10,1],[387,13,391,22,1],[393,13,393,52,1],[394,13,394,44,1],[395,13,395,100,1],[396,13,396,36,1],[397,13,397,29,1],[398,9,398,10,1],[405,9,405,10,1],[406,13,406,54,1],[407,13,407,36,1],[408,13,408,14,1],[409,17,409,56,1],[410,17,410,112,1],[411,17,411,38,1],[412,21,412,112,1],[414,21,414,39,1],[415,13,415,14,1],[418,13,418,32,1],[419,9,419,10,1],[426,9,426,10,0],[427,13,427,54,0],[428,13,428,36,0],[429,13,429,14,0],[430,17,430,56,0],[431,17,431,112,0],[432,17,432,38,0],[433,21,433,82,0],[435,21,435,39,0],[436,13,436,14,0],[438,13,438,37,0],[439,9,439,10,0],[446,9,446,10,0],[447,13,447,54,0],[448,13,448,36,0],[449,13,449,14,0],[450,17,450,56,0],[451,17,451,90,0],[452,17,452,38,0],[453,17,453,18,0],[454,21,454,66,0],[455,21,455,82,0],[458,21,458,39,0],[459,13,459,14,0],[461,13,461,37,0],[462,9,462,10,0],[466,9,466,10,0],[467,13,467,52,0],[468,13,468,42,0],[469,9,469,10,0],[476,9,476,10,0],[477,13,477,52,0],[478,13,478,14,0],[479,17,479,101,0],[481,13,481,53,0],[482,9,482,10,0],[487,9,487,10,0],[488,13,488,48,0],[489,9,489,10,0],[496,9,496,10,0],[498,13,498,105,0],[499,13,499,138,0],[500,13,500,52,0],[501,9,501,10,0],[507,9,507,10,0],[508,13,508,52,0],[510,13,510,35,0],[511,13,511,14,0],[512,17,512,60,0],[515,13,515,30,0],[516,13,516,14,0],[517,17,517,38,0],[519,13,519,110,0],[520,13,520,30,0],[521,13,521,14,0],[522,17,522,98,0],[524,13,524,70,0],[525,13,525,102,0],[526,13,526,80,0],[527,9,527,10,0],[532,9,532,10,0],[533,13,533,30,0],[534,13,534,14,0],[535,17,535,69,0],[538,13,538,110,0],[539,13,539,30,0],[540,13,540,14,0],[541,17,541,69,0],[544,13,544,70,0],[545,13,545,66,0],[546,13,546,67,0],[547,9,547,10,0],[550,9,550,10,1],[551,13,551,58,1],[552,9,552,10,1],[555,9,555,10,1],[556,13,556,69,1],[557,13,558,32,1],[558,32,558,53,0],[558,53,558,82,0],[558,82,558,83,0],[558,32,558,83,0],[558,83,559,33,1],[559,33,559,131,0],[559,131,560,27,1],[557,13,560,27,1],[562,13,567,15,1],[568,9,568,10,1],[571,9,571,10,0],[572,13,572,52,0],[573,13,573,30,0],[574,13,574,14,0],[575,17,575,115,0],[576,17,576,38,0],[577,17,577,18,0],[578,21,578,80,0],[579,21,579,33,0],[581,13,581,14,0],[583,13,583,26,0],[584,9,584,10,0],[587,9,587,10,0],[588,13,588,66,0],[589,13,589,61,0],[590,9,590,10,0],[593,9,593,10,1],[594,13,594,52,1],[595,4,595,21,1],[596,4,596,5,1],[597,17,597,63,1],[598,17,598,127,1],[599,5,599,17,1],[600,5,600,6,0],[601,6,601,46,0],[602,5,602,6,0],[603,4,603,5,1],[604,13,604,48,1],[605,9,605,10,1],[608,9,608,10,1],[609,13,609,20,1],[609,22,609,31,1],[609,32,609,34,1],[609,35,609,48,1],[610,17,610,73,1],[611,9,611,10,1],[614,9,614,10,1],[615,13,615,96,1],[616,9,616,10,1],[619,9,619,10,1],[620,13,620,43,1],[621,17,621,44,0],[623,17,623,58,1],[624,9,624,10,1]]);
    </script>
  </body>
</html>