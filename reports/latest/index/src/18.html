<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\projects\chatle\src\ChatLe.Repository.Identity\ChatStore.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace ChatLe.Models
{
    /// &lt;summary&gt;
    /// Chat store for &lt;see cref=&quot;ChatLeUser&quot;/&gt;
    /// &lt;/summary&gt;
    public class ChatStore : ChatStore&lt;ChatLeUser&gt;
    {
        /// &lt;summary&gt;
        /// Constructor
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;context&quot;&gt;The &lt;see cref=&quot;DbContext&quot; to use/&gt;&lt;/param&gt;
        /// &lt;param name=&quot;userStore&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;env&quot;&gt;&lt;/param&gt;
        public ChatStore(ChatLeIdentityDbContext context, IUserStore&lt;ChatLeUser&gt; userStore, IHostingEnvironment env) 
            : base(context, userStore, env) { }
    }
    
    /// &lt;summary&gt;
    /// Chat store for TUser
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;type of user, must a class and implement &lt;see cref=&quot;IChatUser{string}&quot;/&gt;&lt;/typeparam&gt;
    public class ChatStore&lt;TUser&gt; : ChatStore&lt;string, TUser, DbContext, Conversation, Attendee, Message, NotificationConnection, IdentityUserLogin&lt;string&gt;&gt;
        where TUser : IdentityUser&lt;string&gt;, IChatUser&lt;string&gt;
    {
        /// &lt;summary&gt;
        /// Constructor
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;context&quot;&gt;The &lt;see cref=&quot;DbContext&quot; to use/&gt;&lt;/param&gt;
        /// &lt;param name=&quot;userStore&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;env&quot;&gt;&lt;/param&gt;
        public ChatStore(DbContext context, IUserStore&lt;TUser&gt; userStore, IHostingEnvironment env) 
            : base(context, userStore, env) { }
    }
    
    /// &lt;summary&gt;
    /// Chat store, implement &lt;see cref=&quot;IChatStore{TKey, TUser, TConversation, TAttendee, TMessage, TNotificationConnection}&quot;/&gt;
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TKey&quot;&gt;type of primary key&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;type of user, must be a class and implement &lt;see cref=&quot;IChatUser{TKey}&quot;/&gt;&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TContext&quot;&gt;type of context, must be a &lt;see cref=&quot;DbContext&quot;/&gt;&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TConversation&quot;&gt;type of conversation, must be a &lt;see cref=&quot;Conversation{TKey}&quot;/&gt;&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TAttendee&quot;&gt;type of attendee, must be a &lt;see cref=&quot;Attendee{TKey}&quot;/&gt;&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TMessage&quot;&gt;type of message, must be a &lt;see cref=&quot;Message{TKey}&quot;/&gt;&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TNotificationConnection&quot;&gt;type of notifciation connection, must be a &lt;see cref=&quot;NotificationConnection{TKey}&quot;/&gt;&lt;/typeparam&gt; &lt;summary&gt;
    /// &lt;typeparam name=&quot;TUserLogin&quot;&gt;type of the user login object.&lt;/typeparam&gt;
    /// &lt;/summary&gt;
    public class ChatStore&lt;TKey, TUser, TContext, TConversation, TAttendee, TMessage, TNotificationConnection, TUserLogin&gt; :IChatStore&lt;TKey,TUser, TConversation, TAttendee, TMessage, TNotificationConnection&gt;
        where TKey : IEquatable&lt;TKey&gt;
        where TUser : IdentityUser&lt;TKey&gt;, IChatUser&lt;TKey&gt;
        where TContext : DbContext
        where TConversation : Conversation&lt;TKey&gt;
        where TAttendee : Attendee&lt;TKey&gt;
        where TMessage : Message&lt;TKey&gt;
        where TNotificationConnection : NotificationConnection&lt;TKey&gt;
        where TUserLogin : IdentityUserLogin&lt;TKey&gt;
    {
        readonly IHostingEnvironment _env;
        private readonly IUserStore&lt;TUser&gt; _userStore;

        public IQueryable&lt;TUser&gt; Users { get =&gt; ((IQueryableUserStore&lt;TUser&gt;)_userStore).Users; }

        /// &lt;summary&gt;
        /// Construtor
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;context&quot;&gt;The &lt;see cref=&quot;DbContext&quot; to use/&gt;&lt;/param&gt;
        /// &lt;param name=&quot;userStore&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;env&quot;&gt;&lt;/param&gt;
        public ChatStore(TContext context, IUserStore&lt;TUser&gt; userStore, IHostingEnvironment env)
        {
            Context = context ?? throw new ArgumentNullException(&quot;context&quot;);
            _userStore = userStore ?? throw new ArgumentNullException(&quot;userStore&quot;);
            if (!(_userStore is IQueryableUserStore&lt;TUser&gt;))
            {
                throw new ArgumentException($&quot;{nameof(userStore)} must implements IQueryableUserStore&lt;{typeof(TUser).Name}&gt;&quot;);
            }
            _env = env;
        }

        /// &lt;summary&gt;
        /// Gets the &lt;see cref=&quot;DbContext&quot;/&gt;
        /// &lt;/summary&gt;
        public virtual TContext Context { get; private set; }
        
        /// &lt;summary&gt;
        /// Gets the &lt;see cref=&quot;DbSet{TConversation}&quot;/&gt;
        /// &lt;/summary&gt;
        public DbSet&lt;TConversation&gt; Conversations { get { return Context.Set&lt;TConversation&gt;(); } }
        
        /// &lt;summary&gt;
        /// Gets the &lt;see cref=&quot;DbSet{TMessage}&quot;/&gt;
        /// &lt;/summary&gt;
        public DbSet&lt;TMessage&gt; Messages { get { return Context.Set&lt;TMessage&gt;(); } }
        
        /// &lt;summary&gt;
        /// Gets the &lt;see cref=&quot;DbSet{TAttendee}&quot;/&gt;
        /// &lt;/summary&gt;
        public virtual DbSet&lt;TAttendee&gt; Attendees { get { return Context.Set&lt;TAttendee&gt;(); } }
        
        /// &lt;summary&gt;
        /// Gets the &lt;see cref=&quot;DbSet{TNotificationConnection}&quot;/&gt;
        /// &lt;/summary&gt;
        public virtual DbSet&lt;TNotificationConnection&gt; NotificationConnections { get { return Context.Set&lt;TNotificationConnection&gt;(); } }
                
        /// &lt;summary&gt;
        /// Create a message on the database
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;message&quot;&gt;The message to create&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task&quot;/&gt;&lt;/returns&gt;
        public virtual Task CreateMessageAsync(TMessage message, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            if(message == null)
                throw new ArgumentNullException(&quot;message&quot;);

            Messages.Add(message);
            Context.SaveChanges();

            return Task.FromResult(0);
        }

        /// &lt;summary&gt;
        /// Create an attendee on the database
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;attendee&quot;&gt;The attendee to create&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task&quot;/&gt;&lt;/returns&gt;
        public virtual Task CreateAttendeeAsync(TAttendee attendee, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            if(attendee == null)
            {
                throw new ArgumentNullException(&quot;attendee&quot;);
            }
            Attendees.Add(attendee);
            Context.SaveChanges();

            return Task.FromResult(0);
        }

        /// &lt;summary&gt;
        /// Create a conversation on the database
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;conversation&quot;&gt;The conversation to create&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task&quot;/&gt;&lt;/returns&gt;
        public virtual Task CreateConversationAsync(TConversation conversation, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            if (conversation == null)
                throw new ArgumentNullException(&quot;conversation&quot;);

            Conversations.Add(conversation);
            Context.SaveChanges();

            return Task.FromResult(0);
        }

        /// &lt;summary&gt;
        /// Find a user by her name
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userName&quot;&gt;the user name&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task{TUser}&quot;/&gt;&lt;/returns&gt;
        public virtual Task&lt;TUser&gt; FindUserByNameAsync(string userName, CancellationToken cancellationToken = default(CancellationToken))
            =&gt; GetLoginStore().FindByNameAsync(userName, cancellationToken);

        /// &lt;summary&gt;
        /// Gets a conversation for 2 attendees
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;attendee1&quot;&gt;the 1st attendee&lt;/param&gt;
        /// &lt;param name=&quot;attendee2&quot;&gt;the 2dn attendee&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task{TConversation}&quot;/&gt;&lt;/returns&gt;
        public virtual async Task&lt;TConversation&gt; GetConversationAsync(TUser attendee1, TUser attendee2, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            if (attendee1 == null)
                throw new ArgumentNullException(&quot;attendee1&quot;);
            if (attendee2 == null)
                throw new ArgumentNullException(&quot;attendee2&quot;);

            var convs = (from c in Conversations
                       join a1 in Attendees
                            on c.Id equals a1.ConversationId
                       join a2 in Attendees
                            on c.Id equals a2.ConversationId
                       where a1.UserId.Equals(attendee1.Id)
                            &amp;&amp; a2.UserId.Equals(attendee2.Id)
                            &amp;&amp; c.Attendees.Count.Equals(2)
                       select c)
                       .Include(c =&gt; c.Attendees);

            return await convs.FirstOrDefaultAsync();
        }

        /// &lt;summary&gt;
        /// Gets a conversation by her id
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;convId&quot;&gt;the conversation id&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task{TConversation}&quot;&lt;/returns&gt;
        public virtual async Task&lt;TConversation&gt; GetConversationAsync(TKey convId, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            return await Conversations
                .Include(c =&gt; c.Attendees)
                .FirstOrDefaultAsync(c =&gt; c.Id.Equals(convId));
        }

        /// &lt;summary&gt;
        /// Gets messages in a conversation
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;convId&quot;&gt;the conversation id&lt;/param&gt;
        /// &lt;param name=&quot;max&quot;&gt;max number of messages to get, default is 50&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task{IEnumerable{TMessage}}&quot;/&gt;&lt;/returns&gt;
        public virtual async Task&lt;IEnumerable&lt;TMessage&gt;&gt; GetMessagesAsync(TKey convId, int max = 50, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            return await Messages.Where(m =&gt; m.ConversationId.Equals(convId)).OrderByDescending(m=&gt;m.Date).Take(max).ToListAsync();
        }

        /// &lt;summary&gt;
        /// Gets connected users
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;pageIndex&quot;&gt;the 0 based page index&lt;/param&gt;
        /// &lt;param name=&quot;pageLength&quot;&gt;number of user per page&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task{IEnumerable{TUser}}&quot;/&gt;&lt;/returns&gt;
        public virtual async Task&lt;Page&lt;TUser&gt;&gt; GetUsersConnectedAsync(int pageIndex = 0, int pageLength = 50, CancellationToken cancellationToken = default(CancellationToken))
        {
            var skip = pageIndex * pageLength;
            cancellationToken.ThrowIfCancellationRequested();
            var ids = new List&lt;TKey&gt;();
            var q1 = (from nc in NotificationConnections
                      group new { nc.UserId, nc.ConnectionDate } by nc.UserId into g
                      select new { Id = g.Key, Date = g.Max(x =&gt; x.ConnectionDate) })
                      .OrderByDescending(x =&gt; x.Date);

            var count = q1.Count();

            var q2 = await q1.Skip(skip)
                     .Take(pageLength)
                     .ToListAsync();

            var list = new List&lt;TUser&gt;();
            foreach(var r in q2)
            {
                list.Add(await _userStore.FindByIdAsync(r.Id.ToString(), cancellationToken));
            }

            var pageCount = (int)Math.Floor(((double)count) / pageLength) + 1;

            return await Task.FromResult(new Page&lt;TUser&gt;(list, pageIndex, pageCount));
        }

        /// &lt;summary&gt;
        /// Create a notification connection on the database
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;connection&quot;&gt;the notification connection&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task&quot;/&gt;&lt;/returns&gt;
        public virtual Task CreateNotificationConnectionAsync(TNotificationConnection connection, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            if (connection == null)
                throw new ArgumentNullException(&quot;connection&quot;);

            NotificationConnections.Add(connection);
            try
            {
                Context.SaveChanges();
            }
            catch (DbUpdateConcurrencyException ex)
            {
                foreach (var entry in ex.Entries)
                {
                    var notification = entry.Entity as NotificationConnection&lt;TKey&gt;;
                    if (entry.Entity != null)
                    {
                        entry.State = EntityState.Added;
                        // Using a NoTracking query means we get the entity but it is not tracked by the context
                        // and will not be merged with existing entities in the context.
                        var connectionId = connection.ConnectionId;
                        var type = connection.NotificationType;

                        var databaseEntity = NotificationConnections
                            .AsNoTracking()
                            .FirstOrDefault(nc =&gt; nc.ConnectionId == connectionId &amp;&amp; nc.NotificationType == type);

                        if (databaseEntity == null)
                        {
                            var databaseEntry = Context.Entry(connection);
                            ResetDbEntry&lt;TNotificationConnection&gt;(databaseEntry);
                        }
                    }
                    else
                    {
                        throw new NotSupportedException(&quot;Don&#39;t know how to handle concurrency conflicts for &quot; + entry.Metadata.Name);
                    }
                }

                // Retry the save operation
                Context.SaveChanges();
            }

            return Task.FromResult(0);
        }

        /// &lt;summary&gt;
        /// Delete a notification connection on the database
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;connection&quot;&gt;the notification connection&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task&quot;/&gt;&lt;/returns&gt;
        public virtual Task DeleteNotificationConnectionAsync(TNotificationConnection connection, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            if (connection == null)
                throw new ArgumentNullException(&quot;connection&quot;);

            NotificationConnections.Remove(connection);

            try
            {
                Context.SaveChanges();
            }
            catch (DbUpdateConcurrencyException ex)
            {
                RetryDeleteNotificationConnection(ex);
            }

            return Task.FromResult(0);
        }
        
        /// &lt;summary&gt;
        /// Gets a notification connection by her id and her type
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;connectionId&quot;&gt;the notification connection id&lt;/param&gt;
        /// &lt;param name=&quot;notificationType&quot;&gt;the type of notification&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task{TNotificationConnection}&quot;/&gt;&lt;/returns&gt;
        public virtual async Task&lt;TNotificationConnection&gt; GetNotificationConnectionAsync(string connectionId, string notificationType, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            if (connectionId == null)
                throw new ArgumentNullException(&quot;connectionId&quot;);
            if (notificationType == null)
                throw new ArgumentNullException(&quot;notificationType&quot;);

            return await NotificationConnections
                .FirstOrDefaultAsync(c =&gt; c.ConnectionId == connectionId &amp;&amp; c.NotificationType == notificationType);
        }
        
        /// &lt;summary&gt;
        /// Initialise the database
        /// &lt;/summary&gt;
        public virtual void Init()
        {
            if (_env!= null &amp;&amp;  _env.IsDevelopment())
                Context.Database.EnsureDeletedAsync();

            Context.Database.EnsureCreated();
            NotificationConnections.RemoveRange(NotificationConnections.ToArray());
            Context.SaveChanges();
            Attendees.RemoveRange(Attendees.ToArray());
            Context.SaveChanges();
            Messages.RemoveRange(Messages.ToArray());
            Context.SaveChanges();
            Conversations.RemoveRange(Conversations.ToArray());
            Context.SaveChanges();

            var guess = Users.Where(u =&gt; IsGuess(u, default(CancellationToken)).Result).ToList();
            foreach(var g in guess)
            {
                _userStore.DeleteAsync(g, default(CancellationToken)).GetAwaiter().GetResult();
            }

            Context.SaveChanges();
        }
        
        public virtual async Task&lt;bool&gt; IsGuess(TUser user, CancellationToken cancellationToken = default(CancellationToken))
            =&gt; (await GetLoginStore().GetLoginsAsync(user, cancellationToken)).Any() == false;
        
        /// &lt;summary&gt;
        /// Check if a user has connection
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;the user&lt;/param&gt;
        /// &lt;returns&gt;true if user has connection&lt;/returns&gt;
        public virtual async Task&lt;bool&gt; UserHasConnectionAsync(TUser user)
        {
            return await NotificationConnections.AnyAsync(n =&gt; n.UserId.Equals(user.Id));
        }
        
        /// &lt;summary&gt;
        /// Gets conversations for a user id
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;the user&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task{IEnumerable{TConversation}}&quot;/&gt;&lt;/returns&gt;
        public virtual async Task&lt;IEnumerable&lt;TConversation&gt;&gt; GetConversationsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            return await (from c in Conversations
                          join a in Attendees
                              on c.Id equals a.ConversationId
                          join m in Messages
                              on c.Id equals m.ConversationId
                          where a.UserId.Equals(user.Id)
                          orderby m.Date descending                          
                          select c).Include(c =&gt; c.Attendees).Distinct().ToListAsync();
        }

        /// &lt;summary&gt;
        /// Deletes a user 
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;the user to delete&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;an optional cancellation token&gt;&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task&quot;/&gt;&lt;/returns&gt;
        public virtual async Task DeleteUserAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            if (user == null)
                throw new ArgumentNullException(&quot;user&quot;);

            // Remove all conversations the user attends
            var conversations = await GetConversationsAsync(user, cancellationToken);
            foreach (var conversation in conversations)
            {
                Messages.RemoveRange(Messages.Where(m =&gt; m.ConversationId.Equals(conversation.Id)));
                Attendees.RemoveRange(Attendees.Where(a =&gt; a.ConversationId.Equals(conversation.Id)));
                Conversations.Remove(conversation);
            }
                            
            var userConnections = NotificationConnections.Where(n =&gt; n.UserId.Equals(user.Id));
            NotificationConnections.RemoveRange(userConnections);
            
            try
            {
                await _userStore.DeleteAsync(user, cancellationToken);
                Context.SaveChanges();            
            }
            catch (DbUpdateConcurrencyException ex)
            {
                RetryDeleteUser(ex);
            }
        }

		public Task&lt;TUser&gt; FindUserByIdAsync(TKey id, CancellationToken cancellationToken = default(CancellationToken))
            =&gt; GetLoginStore().FindByIdAsync(id.ToString(), cancellationToken);

        protected virtual IUserLoginStore&lt;TUser&gt; GetLoginStore()
            =&gt; _userStore is IUserLoginStore&lt;TUser&gt; ? _userStore as IUserLoginStore&lt;TUser&gt; : throw new InvalidOperationException(&quot;User store doesn&#39;t implement IUserLoginStore&lt;TUser&gt;&quot;);

        void ResetDbEntry&lt;TEntity&gt;(EntityEntry&lt;TEntity&gt; entry) where TEntity : class
        {
            foreach (var property in entry.Metadata.GetProperties())
            {
                if (property.IsKey())
                    continue;

                entry.Property(property.Name).IsModified = false;
            }
        }

        void RetryDeleteNotificationConnection(DbUpdateConcurrencyException ex)
        {
            foreach (var entry in ex.Entries)
            {
                RetryDeleteNotificationConnection(entry);
            }
        }

        void RetryDeleteNotificationConnection(EntityEntry entry)
        {
            var notification = entry.Entity as NotificationConnection&lt;TKey&gt;;
            if (notification != null)
            {
                // Using a NoTracking query means we get the entity but it is not tracked by the context
                // and will not be merged with existing entities in the context.
                var databaseEntity = NotificationConnections.AsNoTracking().SingleOrDefault(nc =&gt; nc.ConnectionId == notification.ConnectionId &amp;&amp; nc.NotificationType == notification.NotificationType);
                if (databaseEntity == null)
                    return;

                var databaseEntry = Context.Entry(databaseEntity);

                ResetDbEntry(databaseEntry);
            }
            else
            {
                throw new NotSupportedException(&quot;Don&#39;t know how to handle concurrency conflicts for &quot; + entry.Metadata.Name);
            }
        }


        void RetryDeleteUser(DbUpdateConcurrencyException ex)
        {
            foreach (var entry in ex.Entries)
            {
                if (entry.Entity is TNotificationConnection)
                {
                    RetryDeleteNotificationConnection(entry);
                }
                if (entry.Entity is TMessage)
                {
                    RetryDeleteEntity&lt;TMessage&gt;(entry, Messages);
                }
                if (entry.Entity is TAttendee)
                {
                    RetryDeleteEntity&lt;TAttendee&gt;(entry,  entity =&gt; Attendees.AsNoTracking().SingleOrDefault(a =&gt; a.ConversationId.Equals(entity.ConversationId) &amp;&amp; a.UserId.Equals(entity.UserId)));
                }
                if (entry.Entity is TUser)
                {
                    _userStore.DeleteAsync(entry as TUser, default(CancellationToken)).GetAwaiter().GetResult();
                }
            }
        }

        void RetryDeleteEntity&lt;TIdentifiable&gt;(EntityEntry entry, DbSet&lt;TIdentifiable&gt; dbSet) where TIdentifiable: class, IIdentifiable&lt;TKey&gt;
        {
            RetryDeleteEntity&lt;TIdentifiable&gt;(entry, entity =&gt; dbSet.AsNoTracking().SingleOrDefault(m =&gt; m.Id.Equals(entity as TIdentifiable)));
        }

        void RetryDeleteEntity&lt;TEntity&gt;(EntityEntry entry, Func&lt;TEntity, TEntity&gt; getEntity) where TEntity: class
        {
            var entity = entry.Entity as TEntity;
            if (entity != null)
            {
                // Using a NoTracking query means we get the entity but it is not tracked by the context
                // and will not be merged with existing entities in the context.
                var databaseEntity = getEntity(entity);
                if (databaseEntity == null)
                    return;

                var databaseEntry = Context.Entry(databaseEntity);

                ResetDbEntry(databaseEntry);
            }
            else
            {
                throw new NotSupportedException(&quot;Don&#39;t know how to handle concurrency conflicts for &quot; + entry.Metadata.Name);
            }
        }
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[25,15,25,44,1],[25,45,25,46,0],[25,47,25,48,0],[42,15,42,44,1],[42,45,42,46,1],[42,47,42,48,1],[70,49,70,95,1],[78,9,78,97,1],[79,9,79,10,1],[80,13,80,77,1],[81,13,81,84,1],[82,13,82,61,1],[83,13,83,14,1],[84,17,84,127,1],[86,13,86,24,1],[87,9,87,10,1],[92,43,92,47,1],[92,48,92,60,1],[97,57,97,58,1],[97,59,97,95,1],[97,96,97,97,1],[102,47,102,48,1],[102,49,102,80,1],[102,81,102,82,1],[107,57,107,58,1],[107,59,107,91,1],[107,92,107,93,1],[112,85,112,86,1],[112,87,112,133,1],[112,134,112,135,1],[121,9,121,10,1],[122,13,122,62,1],[123,13,123,32,1],[124,17,124,60,1],[126,13,126,35,1],[127,13,127,35,1],[129,13,129,39,1],[130,9,130,10,1],[139,9,139,10,1],[140,13,140,62,1],[141,13,141,33,1],[142,13,142,14,1],[143,17,143,61,1],[145,13,145,37,1],[146,13,146,35,1],[148,13,148,39,1],[149,9,149,10,1],[158,9,158,10,1],[159,13,159,62,1],[160,13,160,38,1],[161,17,161,65,1],[163,13,163,45,1],[164,13,164,35,1],[166,13,166,39,1],[167,9,167,10,1],[176,16,176,76,1],[186,9,186,10,1],[187,13,187,62,1],[188,13,188,35,1],[189,17,189,62,1],[190,13,190,35,1],[191,17,191,62,1],[193,13,202,51,1],[204,13,204,54,1],[205,9,205,10,1],[213,9,213,10,1],[214,13,214,62,1],[215,13,217,64,1],[218,9,218,10,1],[228,9,228,10,1],[229,13,229,62,1],[230,13,230,132,1],[231,9,231,10,1],[241,9,241,10,1],[242,13,242,47,1],[243,13,243,62,1],[244,13,244,40,1],[245,13,248,55,1],[250,13,250,36,1],[252,13,254,37,1],[256,13,256,42,1],[257,13,257,20,1],[257,21,257,26,1],[257,27,257,29,1],[257,30,257,32,1],[258,13,258,14,1],[259,17,259,94,1],[260,13,260,14,1],[262,13,262,79,1],[264,13,264,87,1],[265,9,265,10,1],[274,9,274,10,1],[275,13,275,62,1],[276,13,276,36,1],[277,17,277,63,1],[279,13,279,53,1],[281,13,281,14,1],[282,17,282,39,1],[283,13,283,14,1],[284,13,284,52,0],[285,13,285,14,0],[286,17,286,24,0],[286,26,286,35,0],[286,36,286,38,0],[286,39,286,49,0],[287,17,287,18,0],[288,21,288,85,0],[289,21,289,46,0],[290,21,290,22,0],[291,25,291,57,0],[294,25,294,68,0],[295,25,295,64,0],[297,25,299,115,0],[301,25,301,52,0],[302,25,302,26,0],[303,29,303,75,0],[304,29,304,82,0],[305,25,305,26,0],[306,21,306,22,0],[308,21,308,22,0],[309,25,309,134,0],[311,17,311,18,0],[314,17,314,39,0],[315,13,315,14,0],[317,13,317,39,1],[318,9,318,10,1],[327,9,327,10,1],[328,13,328,62,1],[329,13,329,36,1],[330,17,330,63,1],[332,13,332,56,1],[335,13,335,14,1],[336,17,336,39,1],[337,13,337,14,1],[338,13,338,52,0],[339,13,339,14,0],[340,17,340,55,0],[341,13,341,14,0],[343,13,343,39,1],[344,9,344,10,1],[354,9,354,10,1],[355,13,355,62,1],[356,13,356,38,1],[357,17,357,65,1],[358,13,358,42,1],[359,17,359,69,1],[361,13,362,117,1],[363,9,363,10,1],[369,9,369,10,1],[370,13,370,54,1],[371,17,371,55,0],[373,13,373,46,1],[374,13,374,84,1],[375,13,375,35,1],[376,13,376,56,1],[377,13,377,35,1],[378,13,378,54,1],[379,13,379,35,1],[380,13,380,64,1],[381,13,381,35,1],[383,13,383,98,1],[384,13,384,20,1],[384,21,384,26,0],[384,27,384,29,1],[384,30,384,35,1],[385,13,385,14,0],[386,17,386,96,0],[387,13,387,14,0],[389,13,389,35,1],[390,9,390,10,1],[393,16,393,94,0],[401,9,401,10,1],[402,13,402,90,1],[403,9,403,10,1],[412,9,412,10,1],[413,13,413,62,1],[414,13,421,88,1],[422,9,422,10,1],[431,9,431,10,1],[432,13,432,62,1],[433,13,433,30,1],[434,17,434,57,0],[437,13,437,86,1],[438,13,438,20,1],[438,22,438,38,1],[438,39,438,41,1],[438,42,438,55,1],[439,13,439,14,1],[440,17,440,101,1],[441,17,441,103,1],[442,17,442,52,1],[443,13,443,14,1],[445,13,445,96,1],[446,13,446,66,1],[449,13,449,14,1],[450,17,450,71,1],[451,17,451,39,1],[452,13,452,14,1],[453,13,453,52,0],[454,13,454,14,0],[455,17,455,37,0],[456,13,456,14,0],[457,9,457,10,1],[460,16,460,79,1],[463,16,463,184,1],[466,9,466,10,0],[467,13,467,20,0],[467,22,467,34,0],[467,35,467,37,0],[467,38,467,68,0],[468,13,468,14,0],[469,17,469,38,0],[470,21,470,30,0],[472,17,472,66,0],[473,13,473,14,0],[474,9,474,10,0],[477,9,477,10,0],[478,13,478,20,0],[478,22,478,31,0],[478,32,478,34,0],[478,35,478,45,0],[479,13,479,14,0],[480,17,480,58,0],[481,13,481,14,0],[482,9,482,10,0],[485,9,485,10,0],[486,13,486,77,0],[487,13,487,38,0],[488,13,488,14,0],[491,17,491,201,0],[492,17,492,44,0],[493,21,493,28,0],[495,17,495,67,0],[497,17,497,45,0],[498,13,498,14,0],[500,13,500,14,0],[501,17,501,126,0],[503,9,503,10,0],[507,9,507,10,0],[508,13,508,20,0],[508,22,508,31,0],[508,32,508,34,0],[508,35,508,45,0],[509,13,509,14,0],[510,17,510,61,0],[511,17,511,18,0],[512,21,512,62,0],[513,17,513,18,0],[514,17,514,46,0],[515,17,515,18,0],[516,21,516,66,0],[517,17,517,18,0],[518,17,518,47,0],[519,17,519,18,0],[520,21,520,68,0],[520,68,520,195,0],[520,195,520,197,0],[520,21,520,197,0],[521,17,521,18,0],[522,17,522,43,0],[523,17,523,18,0],[524,21,524,113,0],[525,17,525,18,0],[526,13,526,14,0],[527,9,527,10,0],[530,9,530,10,0],[531,13,531,63,0],[531,63,531,142,0],[531,142,531,144,0],[531,13,531,144,0],[532,9,532,10,0],[535,9,535,10,0],[536,13,536,50,0],[537,13,537,32,0],[538,13,538,14,0],[541,17,541,56,0],[542,17,542,44,0],[543,21,543,28,0],[545,17,545,67,0],[547,17,547,45,0],[548,13,548,14,0],[550,13,550,14,0],[551,17,551,126,0],[553,9,553,10,0]]);
    </script>
  </body>
</html>