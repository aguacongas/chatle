<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\projects\chatle\src\ChatLe.Repository.Identity\ChatStore.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace ChatLe.Models
{
    /// &lt;summary&gt;
    /// Chat store for &lt;see cref=&quot;ChatLeUser&quot;/&gt;
    /// &lt;/summary&gt;
    public class ChatStore : ChatStore&lt;ChatLeUser&gt;
    {
        /// &lt;summary&gt;
        /// Constructor
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;context&quot;&gt;The &lt;see cref=&quot;ChatLeIdentityDbContext&quot;/&gt; to use&lt;/param&gt;
        /// &lt;param name=&quot;loggerFactory&quot;&gt;&lt;/param&gt;
        public ChatStore(ChatLeIdentityDbContext context, IHostingEnvironment env) 
            : base(context, env) { }
    }
    
    /// &lt;summary&gt;
    /// Chat store for TUser
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;type of user, must a class and implement &lt;see cref=&quot;IChatUser{string}&quot;/&gt;&lt;/typeparam&gt;
    public class ChatStore&lt;TUser&gt; : ChatStore&lt;string, TUser, DbContext, Conversation, Attendee, Message, NotificationConnection, IdentityUserLogin&lt;string&gt;&gt;
        where TUser : IdentityUser&lt;string&gt;, IChatUser&lt;string&gt;
    {
        /// &lt;summary&gt;
        /// Constructor
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;context&quot;&gt;The &lt;see cref=&quot;DbContext&quot; to use/&gt;&lt;/param&gt;
        /// &lt;param name=&quot;loggerFactory&quot;&gt;&lt;/param&gt;
        public ChatStore(DbContext context, IHostingEnvironment env) 
            : base(context, env) { }
    }
    
    /// &lt;summary&gt;
    /// Chat store, implement &lt;see cref=&quot;IChatStore{TKey, TUser, TConversation, TAttendee, TMessage, TNotificationConnection}&quot;/&gt;
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TKey&quot;&gt;type of primary key&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;type of user, must be a class and implement &lt;see cref=&quot;IChatUser{TKey}&quot;/&gt;&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TContext&quot;&gt;type of context, must be a &lt;see cref=&quot;DbContext&quot;/&gt;&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TConversation&quot;&gt;type of conversation, must be a &lt;see cref=&quot;Conversation{TKey}&quot;/&gt;&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TAttendee&quot;&gt;type of attendee, must be a &lt;see cref=&quot;Attendee{TKey}&quot;/&gt;&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TMessage&quot;&gt;type of message, must be a &lt;see cref=&quot;Message{TKey}&quot;/&gt;&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TNotificationConnection&quot;&gt;type of notifciation connection, must be a &lt;see cref=&quot;NotificationConnection{TKey}&quot;/&gt;&lt;/typeparam&gt; &lt;summary&gt;
    /// &lt;typeparam name=&quot;TUserLogin&quot;&gt;type of the user login object.&lt;/typeparam&gt;
    /// &lt;/summary&gt;
    public class ChatStore&lt;TKey, TUser, TContext, TConversation, TAttendee, TMessage, TNotificationConnection, TUserLogin&gt; :IChatStore&lt;TKey,TUser, TConversation, TAttendee, TMessage, TNotificationConnection&gt;
        where TKey : IEquatable&lt;TKey&gt;
        where TUser : IdentityUser&lt;TKey&gt;, IChatUser&lt;TKey&gt;
        where TContext : DbContext
        where TConversation : Conversation&lt;TKey&gt;
        where TAttendee : Attendee&lt;TKey&gt;
        where TMessage : Message&lt;TKey&gt;
        where TNotificationConnection : NotificationConnection&lt;TKey&gt;
        where TUserLogin : IdentityUserLogin&lt;TKey&gt;
    {
        readonly IHostingEnvironment _env;
        /// &lt;summary&gt;
        /// Construtor
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;context&quot;&gt;The &lt;see cref=&quot;DbContext&quot; to use/&gt;&lt;/param&gt;
        /// &lt;param name=&quot;loggerFactory&quot;&gt;&lt;/param&gt;
        public ChatStore(TContext context, IHostingEnvironment env)
        {
            if (context == null)
                throw new ArgumentNullException(&quot;context&quot;);

            Context = context;
            _env = env;
        }        
        
        /// &lt;summary&gt;
        /// Gets the &lt;see cref=&quot;DbContext&quot;/&gt;
        /// &lt;/summary&gt;
        public virtual TContext Context { get; private set; }
        
        /// &lt;summary&gt;
        /// Gets the &lt;see cref=&quot;DbSet{TUser}&quot;/&gt;
        /// &lt;/summary&gt;
        public virtual DbSet&lt;TUser&gt; Users { get { return Context.Set&lt;TUser&gt;(); } }
        
        /// &lt;summary&gt;
        /// Gets the &lt;see cref=&quot;DbSet{TConversation}&quot;/&gt;
        /// &lt;/summary&gt;
        public DbSet&lt;TConversation&gt; Conversations { get { return Context.Set&lt;TConversation&gt;(); } }
        
        /// &lt;summary&gt;
        /// Gets the &lt;see cref=&quot;DbSet{TMessage}&quot;/&gt;
        /// &lt;/summary&gt;
        public DbSet&lt;TMessage&gt; Messages { get { return Context.Set&lt;TMessage&gt;(); } }
        
        /// &lt;summary&gt;
        /// Gets the &lt;see cref=&quot;DbSet{TAttendee}&quot;/&gt;
        /// &lt;/summary&gt;
        public virtual DbSet&lt;TAttendee&gt; Attendees { get { return Context.Set&lt;TAttendee&gt;(); } }
        
        /// &lt;summary&gt;
        /// Gets the &lt;see cref=&quot;DbSet{TNotificationConnection}&quot;/&gt;
        /// &lt;/summary&gt;
        public virtual DbSet&lt;TNotificationConnection&gt; NotificationConnections { get { return Context.Set&lt;TNotificationConnection&gt;(); } }
        
        /// &lt;summary&gt;
        /// Gets the &lt;see cref=&quot;DbSet{TUserLogin}&quot;/&gt;
        /// &lt;/summary&gt;
        public virtual DbSet&lt;TUserLogin&gt; Logins { get { return Context.Set&lt;TUserLogin&gt;(); } }
        
        /// &lt;summary&gt;
        /// Create a message on the database
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;message&quot;&gt;The message to create&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task&quot;/&gt;&lt;/returns&gt;
        public virtual Task CreateMessageAsync(TMessage message, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            if(message == null)
                throw new ArgumentNullException(&quot;message&quot;);

            Messages.Add(message);
            Context.SaveChanges();

            return Task.FromResult(0);
        }

        /// &lt;summary&gt;
        /// Create an attendee on the database
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;attendee&quot;&gt;The attendee to create&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task&quot;/&gt;&lt;/returns&gt;
        public virtual Task CreateAttendeeAsync(TAttendee attendee, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            if(attendee == null)
            {
                throw new ArgumentNullException(&quot;attendee&quot;);
            }
            Attendees.Add(attendee);
            Context.SaveChanges();

            return Task.FromResult(0);
        }

        /// &lt;summary&gt;
        /// Create a conversation on the database
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;conversation&quot;&gt;The conversation to create&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task&quot;/&gt;&lt;/returns&gt;
        public virtual Task CreateConversationAsync(TConversation conversation, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            if (conversation == null)
                throw new ArgumentNullException(&quot;conversation&quot;);

            Conversations.Add(conversation);
            Context.SaveChanges();

            return Task.FromResult(0);
        }

        /// &lt;summary&gt;
        /// Find a user by her name
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userName&quot;&gt;the user name&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task{TUser}&quot;/&gt;&lt;/returns&gt;
        public virtual async Task&lt;TUser&gt; FindUserByNameAsync(string userName, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            return await Users
                .SingleOrDefaultAsync(u =&gt; u.UserName == userName, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Gets a conversation for 2 attendees
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;attendee1&quot;&gt;the 1st attendee&lt;/param&gt;
        /// &lt;param name=&quot;attendee2&quot;&gt;the 2dn attendee&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task{TConversation}&quot;/&gt;&lt;/returns&gt;
        public virtual async Task&lt;TConversation&gt; GetConversationAsync(TUser attendee1, TUser attendee2, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            if (attendee1 == null)
                throw new ArgumentNullException(&quot;attendee1&quot;);
            if (attendee2 == null)
                throw new ArgumentNullException(&quot;attendee2&quot;);

            var convs = (from c in Conversations
                       join a1 in Attendees
                            on c.Id equals a1.ConversationId
                       join a2 in Attendees
                            on c.Id equals a2.ConversationId
                       where a1.UserId.Equals(attendee1.Id)
                            &amp;&amp; a2.UserId.Equals(attendee2.Id)
                            &amp;&amp; c.Attendees.Count.Equals(2)
                       select c)
                       .Include(c =&gt; c.Attendees);

            return await convs.FirstOrDefaultAsync();
        }

        /// &lt;summary&gt;
        /// Gets a conversation by her id
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;convId&quot;&gt;the conversation id&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task{TConversation}&quot;&lt;/returns&gt;
        public virtual async Task&lt;TConversation&gt; GetConversationAsync(TKey convId, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            return await Conversations
                .Include(c =&gt; c.Attendees)
                .FirstOrDefaultAsync(c =&gt; c.Id.Equals(convId));
        }

        /// &lt;summary&gt;
        /// Gets messages in a conversation
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;convId&quot;&gt;the conversation id&lt;/param&gt;
        /// &lt;param name=&quot;max&quot;&gt;max number of messages to get, default is 50&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task{IEnumerable{TMessage}}&quot;/&gt;&lt;/returns&gt;
        public virtual async Task&lt;IEnumerable&lt;TMessage&gt;&gt; GetMessagesAsync(TKey convId, int max = 50, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            return await Messages.Where(m =&gt; m.ConversationId.Equals(convId)).OrderByDescending(m=&gt;m.Date).Take(max).ToListAsync();
        }

        /// &lt;summary&gt;
        /// Gets connected users
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;pageIndex&quot;&gt;the 0 based page index&lt;/param&gt;
        /// &lt;param name=&quot;pageLength&quot;&gt;number of user per page&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task{IEnumerable{TUser}}&quot;/&gt;&lt;/returns&gt;
        public virtual async Task&lt;Page&lt;TUser&gt;&gt; GetUsersConnectedAsync(int pageIndex = 0, int pageLength = 50, CancellationToken cancellationToken = default(CancellationToken))
        {
            var skip = pageIndex * pageLength;
            cancellationToken.ThrowIfCancellationRequested();
            var ids = new List&lt;TKey&gt;();
            var q1 = (from nc in NotificationConnections
                      group new { nc.UserId, nc.ConnectionDate } by nc.UserId into g
                      select new { Id = g.Key, Date = g.Max(x =&gt; x.ConnectionDate) })
                      .OrderByDescending(x =&gt; x.Date);

            var count = q1.Count();

            var q2 = await q1.Skip(skip)
                     .Take(pageLength)
                     .ToListAsync();

            var query = from r in q2
                        join u in Users
                         on r.Id equals u.Id
                        select u;

            var pageCount = (int)Math.Floor(((double)count) / pageLength) + 1;

            return await Task.FromResult(new Page&lt;TUser&gt;(query.ToList(), pageIndex, pageCount));
        }

        /// &lt;summary&gt;
        /// Create a notification connection on the database
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;connection&quot;&gt;the notification connection&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task&quot;/&gt;&lt;/returns&gt;
        public virtual Task CreateNotificationConnectionAsync(TNotificationConnection connection, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            if (connection == null)
                throw new ArgumentNullException(&quot;connection&quot;);

            NotificationConnections.Add(connection);
            try
            {
                Context.SaveChanges();
            }
            catch (DbUpdateConcurrencyException ex)
            {
                foreach (var entry in ex.Entries)
                {
                    var notification = entry.Entity as NotificationConnection&lt;TKey&gt;;
                    if (entry.Entity != null)
                    {
                        entry.State = EntityState.Added;
                        // Using a NoTracking query means we get the entity but it is not tracked by the context
                        // and will not be merged with existing entities in the context.
                        var connectionId = connection.ConnectionId;
                        var type = connection.NotificationType;

                        var databaseEntity = NotificationConnections
                            .AsNoTracking()
                            .FirstOrDefault(nc =&gt; nc.ConnectionId == connectionId &amp;&amp; nc.NotificationType == type);

                        if (databaseEntity == null)
                        {
                            var databaseEntry = Context.Entry(connection);
                            ResetDbEntry&lt;TNotificationConnection&gt;(databaseEntry);
                        }
                    }
                    else
                    {
                        throw new NotSupportedException(&quot;Don&#39;t know how to handle concurrency conflicts for &quot; + entry.Metadata.Name);
                    }
                }

                // Retry the save operation
                Context.SaveChanges();
            }

            return Task.FromResult(0);
        }

        /// &lt;summary&gt;
        /// Delete a notification connection on the database
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;connection&quot;&gt;the notification connection&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task&quot;/&gt;&lt;/returns&gt;
        public virtual Task DeleteNotificationConnectionAsync(TNotificationConnection connection, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            if (connection == null)
                throw new ArgumentNullException(&quot;connection&quot;);

            NotificationConnections.Remove(connection);

            try
            {
                Context.SaveChanges();
            }
            catch (DbUpdateConcurrencyException ex)
            {
                RetryDeleteNotificationConnection(ex);
            }

            return Task.FromResult(0);
        }
        
        /// &lt;summary&gt;
        /// Gets a notification connection by her id and her type
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;connectionId&quot;&gt;the notification connection id&lt;/param&gt;
        /// &lt;param name=&quot;notificationType&quot;&gt;the type of notification&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task{TNotificationConnection}&quot;/&gt;&lt;/returns&gt;
        public virtual async Task&lt;TNotificationConnection&gt; GetNotificationConnectionAsync(string connectionId, string notificationType, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            if (connectionId == null)
                throw new ArgumentNullException(&quot;connectionId&quot;);
            if (notificationType == null)
                throw new ArgumentNullException(&quot;notificationType&quot;);

            return await NotificationConnections
                .FirstOrDefaultAsync(c =&gt; c.ConnectionId == connectionId &amp;&amp; c.NotificationType == notificationType);
        }
        
        /// &lt;summary&gt;
        /// Initialise the database
        /// &lt;/summary&gt;
        public virtual void Init()
        {
            if (_env!= null &amp;&amp;  _env.IsDevelopment())
                Context.Database.EnsureDeletedAsync();

            Context.Database.EnsureCreated();
            NotificationConnections.RemoveRange(NotificationConnections.ToArray());
            Context.SaveChanges();
            Attendees.RemoveRange(Attendees.ToArray());
            Context.SaveChanges();
            Messages.RemoveRange(Messages.ToArray());
            Context.SaveChanges();
            Conversations.RemoveRange(Conversations.ToArray());
            Context.SaveChanges();
            Users.RemoveRange(Users.Where(u =&gt; IsGuess(u, default(CancellationToken)).Result).ToArray());
            Context.SaveChanges();
        }
        
        public virtual async Task&lt;bool&gt; IsGuess(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            return await Logins.AnyAsync(l =&gt; l.UserId.Equals(user.Id), cancellationToken) == false;
        }
        /// &lt;summary&gt;
        /// Check if a user has connection
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;the user&lt;/param&gt;
        /// &lt;returns&gt;true if user has connection&lt;/returns&gt;
        public virtual async Task&lt;bool&gt; UserHasConnectionAsync(TUser user)
        {
            return await NotificationConnections.AnyAsync(n =&gt; n.UserId.Equals(user.Id));
        }
        
        /// &lt;summary&gt;
        /// Gets conversations for a user id
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;the user&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;an optional cancellation token&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task{IEnumerable{TConversation}}&quot;/&gt;&lt;/returns&gt;
        public virtual async Task&lt;IEnumerable&lt;TConversation&gt;&gt; GetConversationsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            return await (from c in Conversations
                          join a in Attendees
                              on c.Id equals a.ConversationId
                          join m in Messages
                              on c.Id equals m.ConversationId
                          where a.UserId.Equals(user.Id)
                          orderby m.Date descending                          
                          select c).Include(c =&gt; c.Attendees).Distinct().ToListAsync();
        }

        /// &lt;summary&gt;
        /// Deletes a user 
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;the user to delete&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;an optional cancellation token&gt;&lt;/param&gt;
        /// &lt;returns&gt;a &lt;see cref=&quot;Task&quot;/&gt;&lt;/returns&gt;
        public virtual async Task DeleteUserAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            if (user == null)
                throw new ArgumentNullException(&quot;user&quot;);

            // Remove all conversations the user attends
            var conversations = await GetConversationsAsync(user, cancellationToken);
            foreach (var conversation in conversations)
            {
                Messages.RemoveRange(Messages.Where(m =&gt; m.ConversationId.Equals(conversation.Id)));
                Attendees.RemoveRange(Attendees.Where(a =&gt; a.ConversationId.Equals(conversation.Id)));
                Conversations.Remove(conversation);
            }
                            
            var userConnections = NotificationConnections.Where(n =&gt; n.UserId.Equals(user.Id));
            NotificationConnections.RemoveRange(userConnections);
            
            Users.Remove(user);
            
            try
            {
                Context.SaveChanges();            
            }
            catch (DbUpdateConcurrencyException ex)
            {
                RetryDeleteUser(ex);
            }
        }

		public async Task&lt;TUser&gt; FindUserByIdAsync(TKey id, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
            var user = await Users.SingleOrDefaultAsync(u =&gt; u.Id.Equals(id), cancellationToken);
            return user;
		}

        void ResetDbEntry&lt;TEntity&gt;(EntityEntry&lt;TEntity&gt; entry) where TEntity : class
        {
            foreach (var property in entry.Metadata.GetProperties())
            {
                if (property.IsKey())
                    continue;

                entry.Property(property.Name).IsModified = false;
            }
        }

        void RetryDeleteNotificationConnection(DbUpdateConcurrencyException ex)
        {
            foreach (var entry in ex.Entries)
            {
                RetryDeleteNotificationConnection(entry);
            }
        }

        void RetryDeleteNotificationConnection(EntityEntry entry)
        {
            var notification = entry.Entity as NotificationConnection&lt;TKey&gt;;
            if (notification != null)
            {
                // Using a NoTracking query means we get the entity but it is not tracked by the context
                // and will not be merged with existing entities in the context.
                var databaseEntity = NotificationConnections.AsNoTracking().SingleOrDefault(nc =&gt; nc.ConnectionId == notification.ConnectionId &amp;&amp; nc.NotificationType == notification.NotificationType);
                if (databaseEntity == null)
                    return;

                var databaseEntry = Context.Entry(databaseEntity);

                ResetDbEntry(databaseEntry);
            }
            else
            {
                throw new NotSupportedException(&quot;Don&#39;t know how to handle concurrency conflicts for &quot; + entry.Metadata.Name);
            }
        }


        void RetryDeleteUser(DbUpdateConcurrencyException ex)
        {
            foreach (var entry in ex.Entries)
            {
                if (entry.Entity is TNotificationConnection)
                {
                    RetryDeleteNotificationConnection(entry);
                }
                if (entry.Entity is TMessage)
                {
                    RetryDeleteEntity&lt;TMessage&gt;(entry, Messages);
                }
                if (entry.Entity is TAttendee)
                {
                    RetryDeleteEntity&lt;TAttendee&gt;(entry,  entity =&gt; Attendees.AsNoTracking().SingleOrDefault(a =&gt; a.ConversationId.Equals(entity.ConversationId) &amp;&amp; a.UserId.Equals(entity.UserId)));
                }
                if (entry.Entity is TUser)
                {
                    RetryDeleteEntity&lt;TUser&gt;(entry, Users);
                }
            }
        }

        void RetryDeleteEntity&lt;TIdentifiable&gt;(EntityEntry entry, DbSet&lt;TIdentifiable&gt; dbSet) where TIdentifiable: class, IIdentifiable&lt;TKey&gt;
        {
            RetryDeleteEntity&lt;TIdentifiable&gt;(entry, entity =&gt; dbSet.AsNoTracking().SingleOrDefault(m =&gt; m.Id.Equals(entity as TIdentifiable)));
        }

        void RetryDeleteEntity&lt;TEntity&gt;(EntityEntry entry, Func&lt;TEntity, TEntity&gt; getEntity) where TEntity: class
        {
            var entity = entry.Entity as TEntity;
            if (entity != null)
            {
                // Using a NoTracking query means we get the entity but it is not tracked by the context
                // and will not be merged with existing entities in the context.
                var databaseEntity = getEntity(entity);
                if (databaseEntity == null)
                    return;

                var databaseEntry = Context.Entry(databaseEntity);

                ResetDbEntry(databaseEntry);
            }
            else
            {
                throw new NotSupportedException(&quot;Don&#39;t know how to handle concurrency conflicts for &quot; + entry.Metadata.Name);
            }
        }
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[24,15,24,33,0],[24,34,24,35,0],[24,36,24,37,0],[40,15,40,33,1],[40,34,40,35,1],[40,36,40,37,1],[71,9,71,68,1],[72,9,72,10,1],[73,13,73,33,1],[74,17,74,60,1],[76,13,76,31,1],[77,13,77,24,1],[78,9,78,10,1],[83,43,83,47,1],[83,48,83,60,1],[88,49,88,50,1],[88,51,88,79,1],[88,80,88,81,1],[93,57,93,58,1],[93,59,93,95,1],[93,96,93,97,1],[98,47,98,48,1],[98,49,98,80,1],[98,81,98,82,1],[103,57,103,58,1],[103,59,103,91,1],[103,92,103,93,1],[108,85,108,86,1],[108,87,108,133,1],[108,134,108,135,1],[113,55,113,56,0],[113,57,113,90,0],[113,91,113,92,0],[122,9,122,10,1],[123,13,123,62,1],[124,13,124,32,1],[125,17,125,60,1],[127,13,127,35,1],[128,13,128,35,1],[130,13,130,39,1],[131,9,131,10,1],[140,9,140,10,1],[141,13,141,62,1],[142,13,142,33,1],[143,13,143,14,1],[144,17,144,61,1],[146,13,146,37,1],[147,13,147,35,1],[149,13,149,39,1],[150,9,150,10,1],[159,9,159,10,1],[160,13,160,62,1],[161,13,161,38,1],[162,17,162,65,1],[164,13,164,45,1],[165,13,165,35,1],[167,13,167,39,1],[168,9,168,10,1],[177,9,177,10,1],[178,13,178,62,1],[179,13,180,87,1],[181,9,181,10,1],[191,9,191,10,1],[192,13,192,62,1],[193,13,193,35,1],[194,17,194,62,1],[195,13,195,35,1],[196,17,196,62,1],[198,13,207,51,1],[209,13,209,54,1],[210,9,210,10,1],[218,9,218,10,1],[219,13,219,62,1],[220,13,222,64,1],[223,9,223,10,1],[233,9,233,10,1],[234,13,234,62,1],[235,13,235,132,1],[236,9,236,10,1],[246,9,246,10,1],[247,13,247,47,1],[248,13,248,62,1],[249,13,249,40,1],[250,13,253,55,1],[255,13,255,36,1],[257,13,259,37,1],[261,13,263,29,1],[263,29,263,33,1],[263,33,263,41,1],[263,41,263,45,1],[263,45,264,32,1],[264,32,264,33,1],[264,33,264,34,1],[261,13,264,34,1],[266,13,266,79,1],[268,13,268,97,1],[269,9,269,10,1],[278,9,278,10,1],[279,13,279,62,1],[280,13,280,36,1],[281,17,281,63,1],[283,13,283,53,1],[285,13,285,14,1],[286,17,286,39,1],[287,13,287,14,1],[288,13,288,52,0],[289,13,289,14,0],[290,17,290,24,0],[290,26,290,35,0],[290,36,290,38,0],[290,39,290,49,0],[291,17,291,18,0],[292,21,292,85,0],[293,21,293,46,0],[294,21,294,22,0],[295,25,295,57,0],[298,25,298,68,0],[299,25,299,64,0],[301,25,303,115,0],[305,25,305,52,0],[306,25,306,26,0],[307,29,307,75,0],[308,29,308,82,0],[309,25,309,26,0],[310,21,310,22,0],[312,21,312,22,0],[313,25,313,134,0],[315,17,315,18,0],[318,17,318,39,0],[319,13,319,14,0],[321,13,321,39,1],[322,9,322,10,1],[331,9,331,10,1],[332,13,332,62,1],[333,13,333,36,1],[334,17,334,63,1],[336,13,336,56,1],[339,13,339,14,1],[340,17,340,39,1],[341,13,341,14,1],[342,13,342,52,0],[343,13,343,14,0],[344,17,344,55,0],[345,13,345,14,0],[347,13,347,39,1],[348,9,348,10,1],[358,9,358,10,1],[359,13,359,62,1],[360,13,360,38,1],[361,17,361,65,1],[362,13,362,42,1],[363,17,363,69,1],[365,13,366,117,1],[367,9,367,10,1],[373,9,373,10,1],[374,13,374,54,1],[375,17,375,55,0],[377,13,377,46,1],[378,13,378,84,1],[379,13,379,35,1],[380,13,380,56,1],[381,13,381,35,1],[382,13,382,54,1],[383,13,383,35,1],[384,13,384,64,1],[385,13,385,35,1],[386,13,386,106,1],[387,13,387,35,1],[388,9,388,10,1],[391,9,391,10,0],[392,13,392,101,0],[393,9,393,10,0],[400,9,400,10,1],[401,13,401,90,1],[402,9,402,10,1],[411,9,411,10,1],[412,13,412,62,1],[413,13,420,88,1],[421,9,421,10,1],[430,9,430,10,1],[431,13,431,62,1],[432,13,432,30,1],[433,17,433,57,0],[436,13,436,86,1],[437,13,437,20,1],[437,22,437,38,1],[437,39,437,41,1],[437,42,437,55,1],[438,13,438,14,1],[439,17,439,101,1],[440,17,440,103,1],[441,17,441,52,1],[442,13,442,14,1],[444,13,444,96,1],[445,13,445,66,1],[447,13,447,32,1],[450,13,450,14,1],[451,17,451,39,1],[452,13,452,14,1],[453,13,453,52,0],[454,13,454,14,0],[455,17,455,37,0],[456,13,456,14,0],[457,9,457,10,1],[460,3,460,4,1],[461,4,461,53,1],[462,13,462,98,1],[463,13,463,25,1],[464,3,464,4,1],[467,9,467,10,0],[468,13,468,20,0],[468,22,468,34,0],[468,35,468,37,0],[468,38,468,68,0],[469,13,469,14,0],[470,17,470,38,0],[471,21,471,30,0],[473,17,473,66,0],[474,13,474,14,0],[475,9,475,10,0],[478,9,478,10,0],[479,13,479,20,0],[479,22,479,31,0],[479,32,479,34,0],[479,35,479,45,0],[480,13,480,14,0],[481,17,481,58,0],[482,13,482,14,0],[483,9,483,10,0],[486,9,486,10,0],[487,13,487,77,0],[488,13,488,38,0],[489,13,489,14,0],[492,17,492,201,0],[493,17,493,44,0],[494,21,494,28,0],[496,17,496,67,0],[498,17,498,45,0],[499,13,499,14,0],[501,13,501,14,0],[502,17,502,126,0],[504,9,504,10,0],[508,9,508,10,0],[509,13,509,20,0],[509,22,509,31,0],[509,32,509,34,0],[509,35,509,45,0],[510,13,510,14,0],[511,17,511,61,0],[512,17,512,18,0],[513,21,513,62,0],[514,17,514,18,0],[515,17,515,46,0],[516,17,516,18,0],[517,21,517,66,0],[518,17,518,18,0],[519,17,519,47,0],[520,17,520,18,0],[521,21,521,68,0],[521,68,521,195,0],[521,195,521,197,0],[521,21,521,197,0],[522,17,522,18,0],[523,17,523,43,0],[524,17,524,18,0],[525,21,525,60,0],[526,17,526,18,0],[527,13,527,14,0],[528,9,528,10,0],[531,9,531,10,0],[532,13,532,63,0],[532,63,532,142,0],[532,142,532,144,0],[532,13,532,144,0],[533,9,533,10,0],[536,9,536,10,0],[537,13,537,50,0],[538,13,538,32,0],[539,13,539,14,0],[542,17,542,56,0],[543,17,543,44,0],[544,21,544,28,0],[546,17,546,67,0],[548,17,548,45,0],[549,13,549,14,0],[551,13,551,14,0],[552,17,552,126,0],[554,9,554,10,0]]);
    </script>
  </body>
</html>