<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\projects\chatle\src\chatle\Controllers\AccountController.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using ChatLe.Hubs;
using ChatLe.Models;
using ChatLe.ViewModels;
using System.Net;
using ChatLe.Repository.Identity;
using Microsoft.AspNetCore.Http;
using System.Security.Claims;
using System.Linq;
using Microsoft.Extensions.Logging;
using System.Collections.Generic;
using Microsoft.AspNetCore.SignalR;
using Microsoft.AspNetCore.Http.Authentication;
using Microsoft.AspNetCore.Authentication;
using System;

namespace ChatLe.Controllers
{
    [Authorize]
    public class AccountController : Controller
    {
        public AccountController(UserManager&lt;ChatLeUser&gt; userManager, 
            SignInManager signInManager,
            IChatManager&lt;string, ChatLeUser, Conversation, Attendee, Message, NotificationConnection&gt; chatManager,
            IHubContext&lt;ChatHub&gt; hubContext,
            ILoggerFactory loggerFactory)
        {
            UserManager = userManager;
            SignInManager = signInManager;
            ChatManager = chatManager;
            Logger = loggerFactory.CreateLogger&lt;AccountController&gt;();
            HubContext = hubContext;
        }

        public UserManager&lt;ChatLeUser&gt; UserManager { get; private set; }

        public SignInManager&lt;ChatLeUser&gt; SignInManager { get; private set; }

        public IChatManager&lt;string, ChatLeUser, Conversation, Attendee, Message, NotificationConnection&gt; ChatManager { get; private set; }

        public ILogger Logger { get; private set; }

        public IHubContext&lt;ChatHub&gt; HubContext { get; private set; }

        // GET: /Account/Index
        [HttpGet]
        [AllowAnonymous]
        public IActionResult Index(string returnUrl = null, string reason = null)
        {
            ViewBag.ReturnUrl = returnUrl;
            DeleteExternalCookie();
            return View(new LoginPageViewModel());
        }

        //
        // POST: /Account/Login
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; Login(LoginViewModel model, string returnUrl = null)
        {
            if (ModelState.IsValid)
            {
                var signInStatus = await SignInManager.PasswordSignInAsync(model.UserName, model.Password, model.RememberMe, lockoutOnFailure: false);

                if (signInStatus.Succeeded)
                    return RedirectToLocal(returnUrl);

                ModelState.AddModelError(&quot;&quot;, &quot;Invalid username or password.&quot;);
                return View(model);
            }

            // If we got this far, something failed, redisplay form
            return View(&quot;Index&quot;, new LoginPageViewModel() { Login = model });
        }

        //
        // POST: /Account/SpaLogin
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]

        public async Task&lt;IActionResult&gt; SpaLogin([FromBody] LoginViewModel model)
        {
            if (ModelState.IsValid)
            {
                var signInStatus = await SignInManager.PasswordSignInAsync(model.UserName, model.Password, model.RememberMe, lockoutOnFailure: false);

                if (signInStatus.Succeeded)
                    return new JsonResult(signInStatus.Succeeded);

                ModelState.AddModelError(&quot;InvalidUserOrPAssword&quot;, &quot;Invalid username or password.&quot;);                
            }

            return ReturnSpaError();
        }

        //
        // POST: /Account/Guess
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; Guess(GuessViewModel model, string returnUrl = null)
        {
            if (ModelState.IsValid)
            {
                var user = new ChatLeUser { UserName = model.UserName };

                var result = await UserManager.CreateAsync(user);
                
                if (result.Succeeded)
                {
                    await SignInManager.SignInAsync(user, isPersistent: false);
                    return RedirectToAction(&quot;Index&quot;, &quot;Home&quot;);
                }
                else
                    AddErrors(result);
            }

            // If we got this far, something failed, redisplay form
            return View(&quot;Index&quot;, new LoginPageViewModel() { Guess = model });
        }

        //
        // POST: /Account/SpaGuess
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]

        public async Task&lt;JsonResult&gt; SpaGuess([FromBody] GuessViewModel model)
        {
            if (ModelState.IsValid)
            {
                var user = new ChatLeUser { UserName = model.UserName };
                var result = await UserManager.CreateAsync(user);
                if (result.Succeeded)
                {
                    await SignInManager.SignInAsync(user, isPersistent: false);
                    return new JsonResult(result.Succeeded);
                }
                else
                {
                    AddErrors(result);
                }
            }

            return ReturnSpaError();
        }

        //
        // GET: /Account/Register
        [AllowAnonymous]
        [HttpGet]
        public IActionResult Register()
        {
            return View();
        }

        //
        // POST: /Account/Register
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; Register(RegisterViewModel model)
        {
            if (ModelState.IsValid)
            {
                var user = new ChatLeUser { UserName = model.UserName };
                var result = await UserManager.CreateAsync(user, model.Password);

                if (result.Succeeded)
                {
                    await SignInManager.SignInAsync(user, isPersistent: false);
                    return RedirectToAction(&quot;Index&quot;, &quot;Home&quot;);
                }
                else
                    AddErrors(result);
            }

            // If we got this far, something failed, redisplay form
            return View(model);
        }

        //
        // POST: /Account/LogOff
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; LogOff(string reason = null)
        {
            await SignOut();
			return RedirectToAction(&quot;Index&quot;, routeValues: new { Reason = reason });
        }

        //
        // POST: /Account/SpaLogOff
        [HttpPost]
        [ValidateAntiForgeryToken]

        public async Task SpaLogOff(string reason = null)
        {
            await SignOut();        
        }

        //
        // GET: /Account/ExternalLoginCallback
        [HttpGet]
        [AllowAnonymous]
        public IEnumerable&lt;ExternalLoginProvider&gt; GetExternalProviders(){
            return SignInManager.GetExternalAuthenticationSchemesAsync().Result.Select(p =&gt; new ExternalLoginProvider
                { 
                    DisplayName = p.DisplayName,
                    AuthenticationScheme = p.Name  
                });
        }

        //
        // POST: /Account/ExternalLogin
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]

        public IActionResult ExternalLogin(string provider, string returnUrl = null)
        {
            // Request a redirect to the external login provider.
            var redirectUrl = Url.Action(&quot;ExternalLoginCallback&quot;, &quot;Account&quot;, new { ReturnUrl = returnUrl });
            var properties = SignInManager.ConfigureExternalAuthenticationProperties(provider, redirectUrl, UserManager.GetUserId(User));
            return Challenge(properties, provider);
        }

        //
        // GET: /Account/ExternalLoginCallback
        [HttpGet]
        [AllowAnonymous]
        public async Task&lt;IActionResult&gt; ExternalLoginCallback(string returnUrl = null, string remoteError = null)
        {
            if (returnUrl != null)
            {
                return await SpaExternalLogin(returnUrl, remoteError);
            }

            if (remoteError != null)
            {
                ModelState.AddModelError(string.Empty, $&quot;Error from external provider: {remoteError}&quot;);
                return View(nameof(Login));
            }

            var info = await SignInManager.GetExternalLoginInfoAsync();
            if (info == null)
            {
                return RedirectToAction(nameof(Index));
            }

            // Sign in the user with this external login provider if the user already has a login.
            var result = await SignInManager.ExternalLoginSignInAsync(info.LoginProvider, info.ProviderKey, isPersistent: false);
            if (result.Succeeded)
            {
                // Update any authentication tokens if login succeeded
                await SignInManager.UpdateExternalAuthenticationTokensAsync(info);

                return RedirectToLocal(returnUrl);
            }

            // If the user does not have an account, then ask the user to create an account.
            ViewData[&quot;LoginProvider&quot;] = info.LoginProvider;
            var name = info.Principal.FindFirstValue(ClaimTypes.Name);

            return View(&quot;ExternalLoginConfirmation&quot;, new ExternalLoginConfirmationViewModel { UserName = name });
        }

        private async Task&lt;IActionResult&gt; SpaExternalLogin(string returnUrl, string remoteError)
        {
            if (remoteError != null)
            {
                return new RedirectResult($&quot;{returnUrl}?e={remoteError}&quot;);
            }

            var info = await SignInManager.GetExternalLoginInfoAsync();
            if (info == null)
            {
                return new RedirectResult($&quot;{returnUrl}&quot;);
            }

            var name = info.Principal.FindFirstValue(ClaimTypes.Name);
            // Sign in the user with this external login provider if the user already has a login.
            var result = await SignInManager.ExternalLoginSignInAsync(info.LoginProvider, info.ProviderKey, isPersistent: false);
            if (result.Succeeded)
            {
                // Update any authentication tokens if login succeeded
                await SignInManager.UpdateExternalAuthenticationTokensAsync(info);
                
                var user = await UserManager.FindByLoginAsync(info.LoginProvider, info.ProviderKey);
                
                return new RedirectResult($&quot;{returnUrl}?u={user.UserName}&quot;);
            }

            // If the user does not have an account, then ask the user to create an account.
            return new RedirectResult($&quot;{returnUrl}?p={info.LoginProvider}&amp;u={name}&quot;);
        }

        //
        // POST: /Account/ExternalLoginConfirmation
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; ExternalLoginConfirmation(ExternalLoginConfirmationViewModel model, string returnUrl = null)
        {
            if (ModelState.IsValid)
            {
                // Get the information about the user from the external login provider
                var info = await SignInManager.GetExternalLoginInfoAsync();
                if (info == null)
                {
                    return View(&quot;ExternalLoginFailure&quot;);
                }
                var user = new ChatLeUser { UserName = model.UserName };
                var result = await UserManager.CreateAsync(user);
                if (result.Succeeded)
                {
                    result = await UserManager.AddLoginAsync(user, info);
                    if (result.Succeeded)
                    {
                        await SignInManager.SignInAsync(user, isPersistent: false);

                        // Update any authentication tokens as well
                        await SignInManager.UpdateExternalAuthenticationTokensAsync(info);

                        return RedirectToLocal(returnUrl);
                    }
                }
                AddErrors(result);
            }

            ViewData[&quot;ReturnUrl&quot;] = returnUrl;
            return View(model);
        }


        //
        // POST: /Account/SpaExternalLoginConfirmation
        [HttpPut]
        [AllowAnonymous]
        public async Task&lt;JsonResult&gt; SpaExternalLoginConfirmation([FromBody] ExternalLoginConfirmationViewModel model)
        {
            if (ModelState.IsValid)
            {
                // Get the information about the user from the external login provider
                var info = await SignInManager.GetExternalLoginInfoAsync();
                if (info == null)
                {
                    ModelState.AddModelError(&quot;NullInfo&quot;, &quot;External login info is null&quot;);
                }
                else
                {
                    var user = new ChatLeUser { UserName = model.UserName };
                    var result = await UserManager.CreateAsync(user);
                    if (result.Succeeded)
                    {
                        result = await UserManager.AddLoginAsync(user, info);
                        if (result.Succeeded)
                        {
                            await SignInManager.SignInAsync(user, isPersistent: false);

                            // Update any authentication tokens as well
                            await SignInManager.UpdateExternalAuthenticationTokensAsync(info);

                            return new JsonResult(&quot;OK&quot;);
                        }
                    }

                    AddErrors(result);
                }
            }

            return ReturnSpaError();
        }

        [HttpGet]
        [AllowAnonymous]
        public async Task&lt;bool&gt; Exists(string userName)
        {
            return await UserManager.FindByNameAsync(userName) != null;
        }

        //GET: /Manage/Manage
        [HttpGet]
        public async Task&lt;IActionResult&gt; Manage(ManageMessageId? message = null)
        {
            ViewData[&quot;StatusMessage&quot;] =
                message == ManageMessageId.RemoveLoginSuccess ? &quot;The external login was removed.&quot;
                : message == ManageMessageId.AddLoginSuccess ? &quot;The external login was added.&quot;
                : message == ManageMessageId.Error ? &quot;An error has occurred.&quot;
                : &quot;&quot;;

            var user = await GetCurrentUserAsync();
            var vm = await GetLogins(user);
            ViewData[&quot;ShowRemoveButton&quot;] = user.PasswordHash != null || vm.CurrentLogins.Count &gt; 1;
            DeleteExternalCookie();
            return View(vm);
        }

        //
        // POST: /Account/UpdatePassword
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; UpdatePassword(UpdatePasswordViewModel model)
        {
            ViewBag.ReturnUrl = Url.Action(&quot;Manage&quot;);
            if (ModelState.IsValid)
            {
                var user = await GetCurrentUserAsync();
                var result = await UserManager.ChangePasswordAsync(user, model.OldPassword, model.NewPassword);
                if (result.Succeeded)
                    return RedirectToAction(&quot;Manage&quot;, new { Message = ManageMessageId.ChangePasswordSuccess });
                else
                    AddErrors(result);
            }

            // If we got this far, something failed, redisplay form
            return View(model);
        }

        //
        // PUT: /Account/ChangePassword
        [HttpPut]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; ChangePassword([FromBody] UpdatePasswordViewModel model)
        {
            ViewBag.ReturnUrl = Url.Action(&quot;Manage&quot;);
            if (ModelState.IsValid)
            {
                var user = await GetCurrentUserAsync();
                var result = await UserManager.ChangePasswordAsync(user, model.OldPassword, model.NewPassword);
                if (result.Succeeded)
                    return new JsonResult(ManageMessageId.ChangePasswordSuccess);
                else
                    AddErrors(result);
            }

            return ReturnSpaError();
        }

        //
        // POST: /Account/SetPassword
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; SetPassword([FromBody] CreatePasswordViewModel model)
        {
            ViewBag.ReturnUrl = Url.Action(&quot;Manage&quot;);
            if (ModelState.IsValid)
            {
                var user = await GetCurrentUserAsync();
                var result = await UserManager.AddPasswordAsync(user, model.NewPassword);
                if (result.Succeeded)
                {
                    await SignInManager.SignInAsync(user, false);
                    return new JsonResult(ManageMessageId.ChangePasswordSuccess);
                }
                else
                    AddErrors(result);
            }

            return ReturnSpaError();
        }

        [HttpGet]
        public async Task&lt;ManageLoginsViewModel&gt; Logins()
        {
            var user = await GetCurrentUserAsync();
            return await GetLogins(user);
        }

        //
        // POST: /Manage/RemoveLogin
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task&lt;IActionResult&gt; RemoveLogin(RemoveLoginViewModel account)
        {
            if (await InternalRemoveLogin(account))
            {
                return RedirectToAction(nameof(Manage), new { ManageMessageId.RemoveLoginSuccess });
            }
            return RedirectToAction(nameof(Manage));
        }

        [HttpDelete]
        public async Task SpaRemoveLogin(RemoveLoginViewModel account)
        {
            await InternalRemoveLogin(account);
        }

        //
        // POST: /Manage/LinkLogin
        [HttpPost]
        [ValidateAntiForgeryToken]
        public IActionResult LinkLogin(string provider, string returnUrl = null)
        {
            // Request a redirect to the external login provider to link a login for the current user
            var redirectUrl = Url.Action(&quot;LinkLoginCallback&quot;, &quot;Account&quot;, new { ReturnUrl = returnUrl });
            var properties = SignInManager.ConfigureExternalAuthenticationProperties(provider, redirectUrl, UserManager.GetUserId(User));            
            return Challenge(properties, provider);
        }

        //
        // GET: /Manage/LinkLoginCallback
        [HttpGet]
        public async Task&lt;ActionResult&gt; LinkLoginCallback(string returnUrl = null)
        {
            var user = await GetCurrentUserAsync();

            if (returnUrl != null)
            {
                return await SpaLinkLogin(user, returnUrl);
            }

            if (user == null)
            {
                return View(&quot;Error&quot;);
            }
            var info = await SignInManager.GetExternalLoginInfoAsync(await UserManager.GetUserIdAsync(user));
            if (info == null)
            {
                return RedirectToAction(nameof(Manage), new { Message = ManageMessageId.Error });
            }
            var result = await UserManager.AddLoginAsync(user, info);
            var message = result.Succeeded ? ManageMessageId.AddLoginSuccess : ManageMessageId.Error;
            return RedirectToAction(nameof(Manage), new { Message = message });
        }

        #region Helpers

        private async Task&lt;ActionResult&gt; SpaLinkLogin(ChatLeUser user, string returnUrl)
        {
            if (user == null)
            {
                return new RedirectResult($&quot;{returnUrl}&amp;r=no-user&quot;);
            }

            var info = await SignInManager.GetExternalLoginInfoAsync(await UserManager.GetUserIdAsync(user));
            if (info == null)
            {
                return new RedirectResult($&quot;{returnUrl}&amp;r=no-info&quot;);
            }

            var result = await UserManager.AddLoginAsync(user, info);
            var message = result.Succeeded ? &quot;succeed&quot; : &quot;error&quot;;
            return new RedirectResult($&quot;{returnUrl}&amp;r={message}&quot;);
        }

        private void DeleteExternalCookie()
        {
            Response.Cookies.Delete(&quot;Identity.External&quot;);
        }

        private async Task&lt;ManageLoginsViewModel&gt; GetLogins(ChatLeUser user)
        {
            var userLogins = await UserManager.GetLoginsAsync(user);
            var otherLogins = (await SignInManager.GetExternalAuthenticationSchemesAsync())
                .Where(auth =&gt; userLogins.All(ul =&gt; auth.Name != ul.LoginProvider))
                .Select(auth =&gt; new AuthenticationDescription { AuthenticationScheme = auth.Name, DisplayName = auth.DisplayName })
                .ToList();

            return new ManageLoginsViewModel
            {
                CurrentLogins = userLogins,
                OtherLogins = otherLogins,
                Passwords = user.PasswordHash != null ? new UpdatePasswordViewModel() : null                
            };
        }

        private async Task&lt;bool&gt; InternalRemoveLogin(RemoveLoginViewModel account)
        {
            var user = await GetCurrentUserAsync();
            if (user != null)
            {
                var result = await UserManager.RemoveLoginAsync(user, account.LoginProvider, account.ProviderKey);
                if (result.Succeeded)
                {
                    await SignInManager.SignInAsync(user, isPersistent: false);
                    return true;
                }
            }

            return false;
        }

        private JsonResult ReturnSpaError()
        {
            Response.StatusCode = (int)HttpStatusCode.BadRequest;
            return new JsonResult(ModelState.Root.Children);            
        }

        private async Task SignOut()
        {
            var user = await GetCurrentUserAsync();
			if (user != null)
			{
                try
                {
                    user.IsGuess = await ChatManager.IsGuess(user);
                    await HubContext.Clients.All.SendAsync(&quot;userDisconnected&quot;, new { id = user.UserName, isRemoved = user.IsGuess });
                    if (user.IsGuess)
                    {
                        await ChatManager.RemoveUserAsync(user);
                    }
                }
                catch(Exception e)
                {
                    Logger.LogError(e, &quot;AccountController Signout error . {0}&quot;, e.Message);
                }
            }
            await SignInManager.SignOutAsync();
        }

        private void AddErrors(IdentityResult result)
        {
            foreach (var error in result.Errors)
                ModelState.AddModelError(error.Code, error.Description);
        }

        private async Task&lt;ChatLeUser&gt; GetCurrentUserAsync()
        {
            return await ChatManager.Store.FindUserByNameAsync(HttpContext.User.Identity.Name);
        }

        private IActionResult RedirectToLocal(string returnUrl)
        {
            if (Url.IsLocalUrl(returnUrl))
                return Redirect(returnUrl);
            else
                return RedirectToAction(&quot;Index&quot;, &quot;Home&quot;);
        }

        public enum ManageMessageId
        {
            ChangePasswordSuccess,
            Error,
            AddLoginSuccess,
            RemoveLoginSuccess
        }
        #endregion
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[25,9,29,42,1],[30,9,30,10,1],[31,13,31,39,1],[32,13,32,43,1],[33,13,33,39,1],[34,13,34,70,1],[35,13,35,37,1],[36,9,36,10,1],[38,54,38,58,1],[38,59,38,71,1],[40,58,40,62,1],[40,63,40,75,1],[42,120,42,124,1],[42,125,42,137,1],[44,33,44,37,0],[44,38,44,50,1],[46,50,46,54,1],[46,55,46,67,1],[52,9,52,10,1],[53,13,53,43,1],[54,13,54,36,1],[55,13,55,51,1],[56,9,56,10,1],[64,9,64,10,1],[65,13,65,36,1],[66,13,66,14,1],[67,17,67,151,1],[69,17,69,44,1],[70,21,70,55,1],[72,17,72,79,1],[73,17,73,36,1],[77,13,77,78,0],[78,9,78,10,1],[87,9,87,10,0],[88,13,88,36,0],[89,13,89,14,0],[90,17,90,151,0],[92,17,92,44,0],[93,21,93,67,0],[95,17,95,100,0],[96,13,96,14,0],[98,13,98,37,0],[99,9,99,10,0],[107,9,107,10,1],[108,13,108,36,1],[109,13,109,14,1],[110,17,110,73,1],[112,17,112,66,1],[114,17,114,38,1],[115,17,115,18,1],[116,21,116,80,1],[117,21,117,62,1],[120,21,120,39,1],[121,13,121,14,1],[124,13,124,78,1],[125,9,125,10,1],[134,9,134,10,0],[135,13,135,36,0],[136,13,136,14,0],[137,17,137,73,0],[138,17,138,66,0],[139,17,139,38,0],[140,17,140,18,0],[141,21,141,80,0],[142,21,142,61,0],[145,17,145,18,0],[146,21,146,39,0],[147,17,147,18,0],[148,13,148,14,0],[150,13,150,37,0],[151,9,151,10,0],[158,9,158,10,1],[159,13,159,27,1],[160,9,160,10,1],[168,9,168,10,1],[169,13,169,36,1],[170,13,170,14,1],[171,17,171,73,1],[172,17,172,82,1],[174,17,174,38,1],[175,17,175,18,1],[176,21,176,80,1],[177,21,177,62,1],[180,21,180,39,1],[181,13,181,14,1],[184,13,184,32,1],[185,9,185,10,1],[192,9,192,10,1],[193,13,193,29,1],[194,4,194,75,1],[195,9,195,10,1],[203,9,203,10,0],[204,13,204,29,0],[205,9,205,10,0],[211,73,211,74,0],[212,13,212,93,0],[212,93,216,18,0],[216,18,216,20,0],[212,13,216,20,0],[217,9,217,10,0],[226,9,226,10,0],[228,13,228,109,0],[229,13,229,138,0],[230,13,230,52,0],[231,9,231,10,0],[238,9,238,10,0],[239,13,239,35,0],[240,13,240,14,0],[241,17,241,71,0],[244,13,244,37,0],[245,13,245,14,0],[246,17,246,104,0],[247,17,247,44,0],[250,13,250,72,0],[251,13,251,30,0],[252,13,252,14,0],[253,17,253,56,0],[257,13,257,130,0],[258,13,258,34,0],[259,13,259,14,0],[261,17,261,83,0],[263,17,263,51,0],[267,13,267,60,0],[268,13,268,71,0],[270,13,270,114,0],[271,9,271,10,0],[274,9,274,10,0],[275,13,275,37,0],[276,13,276,14,0],[277,17,277,75,0],[280,13,280,72,0],[281,13,281,30,0],[282,13,282,14,0],[283,17,283,59,0],[286,13,286,71,0],[288,13,288,130,0],[289,13,289,34,0],[290,13,290,14,0],[292,17,292,83,0],[294,17,294,101,0],[296,17,296,77,0],[300,13,300,87,0],[301,9,301,10,0],[309,9,309,10,0],[310,13,310,36,0],[311,13,311,14,0],[313,17,313,76,0],[314,17,314,34,0],[315,17,315,18,0],[316,21,316,57,0],[318,17,318,73,0],[319,17,319,66,0],[320,17,320,38,0],[321,17,321,18,0],[322,21,322,74,0],[323,21,323,42,0],[324,21,324,22,0],[325,25,325,84,0],[328,25,328,91,0],[330,25,330,59,0],[332,17,332,18,0],[333,17,333,35,0],[334,13,334,14,0],[336,13,336,47,0],[337,13,337,32,0],[338,9,338,10,0],[346,9,346,10,0],[347,13,347,36,0],[348,13,348,14,0],[350,17,350,76,0],[351,17,351,34,0],[352,17,352,18,0],[353,21,353,89,0],[354,17,354,18,0],[356,17,356,18,0],[357,21,357,77,0],[358,21,358,70,0],[359,21,359,42,0],[360,21,360,22,0],[361,25,361,78,0],[362,25,362,46,0],[363,25,363,26,0],[364,29,364,88,0],[367,29,367,95,0],[369,29,369,57,0],[371,21,371,22,0],[373,21,373,39,0],[374,17,374,18,0],[375,13,375,14,0],[377,13,377,37,0],[378,9,378,10,0],[383,9,383,10,0],[384,13,384,72,0],[385,9,385,10,0],[390,9,390,10,1],[391,13,395,22,1],[397,13,397,52,1],[398,13,398,44,1],[399,13,399,100,1],[400,13,400,36,1],[401,13,401,29,1],[402,9,402,10,1],[409,9,409,10,1],[410,13,410,54,1],[411,13,411,36,1],[412,13,412,14,1],[413,17,413,56,1],[414,17,414,112,1],[415,17,415,38,1],[416,21,416,112,1],[418,21,418,39,1],[419,13,419,14,1],[422,13,422,32,1],[423,9,423,10,1],[430,9,430,10,0],[431,13,431,54,0],[432,13,432,36,0],[433,13,433,14,0],[434,17,434,56,0],[435,17,435,112,0],[436,17,436,38,0],[437,21,437,82,0],[439,21,439,39,0],[440,13,440,14,0],[442,13,442,37,0],[443,9,443,10,0],[450,9,450,10,0],[451,13,451,54,0],[452,13,452,36,0],[453,13,453,14,0],[454,17,454,56,0],[455,17,455,90,0],[456,17,456,38,0],[457,17,457,18,0],[458,21,458,66,0],[459,21,459,82,0],[462,21,462,39,0],[463,13,463,14,0],[465,13,465,37,0],[466,9,466,10,0],[470,9,470,10,0],[471,13,471,52,0],[472,13,472,42,0],[473,9,473,10,0],[480,9,480,10,0],[481,13,481,52,0],[482,13,482,14,0],[483,17,483,101,0],[485,13,485,53,0],[486,9,486,10,0],[490,9,490,10,0],[491,13,491,48,0],[492,9,492,10,0],[499,9,499,10,0],[501,13,501,105,0],[502,13,502,138,0],[503,13,503,52,0],[504,9,504,10,0],[510,9,510,10,0],[511,13,511,52,0],[513,13,513,35,0],[514,13,514,14,0],[515,17,515,60,0],[518,13,518,30,0],[519,13,519,14,0],[520,17,520,38,0],[522,13,522,110,0],[523,13,523,30,0],[524,13,524,14,0],[525,17,525,98,0],[527,13,527,70,0],[528,13,528,102,0],[529,13,529,80,0],[530,9,530,10,0],[535,9,535,10,0],[536,13,536,30,0],[537,13,537,14,0],[538,17,538,69,0],[541,13,541,110,0],[542,13,542,30,0],[543,13,543,14,0],[544,17,544,69,0],[547,13,547,70,0],[548,13,548,66,0],[549,13,549,67,0],[550,9,550,10,0],[553,9,553,10,1],[554,13,554,58,1],[555,9,555,10,1],[558,9,558,10,1],[559,13,559,69,1],[560,13,561,32,1],[561,32,561,53,0],[561,53,561,82,0],[561,82,561,83,0],[561,32,561,83,0],[561,83,562,33,1],[562,33,562,131,0],[562,131,563,27,1],[560,13,563,27,1],[565,13,570,15,1],[571,9,571,10,1],[574,9,574,10,0],[575,13,575,52,0],[576,13,576,30,0],[577,13,577,14,0],[578,17,578,115,0],[579,17,579,38,0],[580,17,580,18,0],[581,21,581,80,0],[582,21,582,33,0],[584,13,584,14,0],[586,13,586,26,0],[587,9,587,10,0],[590,9,590,10,0],[591,13,591,66,0],[592,13,592,61,0],[593,9,593,10,0],[596,9,596,10,1],[597,13,597,52,1],[598,4,598,21,1],[599,4,599,5,1],[601,17,601,18,1],[602,21,602,68,1],[603,21,603,134,1],[604,21,604,38,1],[605,21,605,22,0],[606,25,606,65,0],[607,21,607,22,0],[608,17,608,18,1],[609,17,609,35,0],[610,17,610,18,0],[611,21,611,92,0],[612,17,612,18,0],[613,13,613,14,1],[614,13,614,48,1],[615,9,615,10,1],[618,9,618,10,1],[619,13,619,20,1],[619,22,619,31,1],[619,32,619,34,1],[619,35,619,48,1],[620,17,620,73,1],[621,9,621,10,1],[624,9,624,10,1],[625,13,625,96,1],[626,9,626,10,1],[629,9,629,10,1],[630,13,630,43,1],[631,17,631,44,0],[633,17,633,58,1],[634,9,634,10,1]]);
    </script>
  </body>
</html>